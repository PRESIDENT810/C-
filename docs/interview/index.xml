<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interviews on C&#43;&#43; Interview Notes</title>
    <link>https://president810.github.io/Cpp-Interview-Notes/interview/</link>
    <description>Recent content in Interviews on C&#43;&#43; Interview Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Dec 2020 23:42:19 +0800</lastBuildDate><atom:link href="https://president810.github.io/Cpp-Interview-Notes/interview/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;</title>
      <link>https://president810.github.io/Cpp-Interview-Notes/interview/c&#43;&#43;/</link>
      <pubDate>Thu, 24 Dec 2020 23:42:19 +0800</pubDate>
      
      <guid>https://president810.github.io/Cpp-Interview-Notes/interview/c&#43;&#43;/</guid>
      <description>
        
          &lt;h2 id=&#34;c&#34;&gt;C++&lt;/h2&gt;
&lt;h3 id=&#34;内存机制&#34;&gt;内存机制&lt;/h3&gt;
&lt;h4 id=&#34;基本数据类型&#34;&gt;基本数据类型&lt;/h4&gt;
&lt;p&gt;char(1字节），bool（1字节），short（2字节），int（4字节），long（8字节），float（4字节），double（8字节）&lt;/p&gt;
&lt;h4 id=&#34;怎么判断float或者double为0&#34;&gt;怎么判断float或者double为0&lt;/h4&gt;
&lt;p&gt;float32位中，有1位符号位，8位指数位，23位尾数为 double64位中，1位符号位，11位指数位，52位尾数位；&lt;/p&gt;
&lt;p&gt;float的精度误差在1e-6；double精度误差在1e-15&lt;/p&gt;
&lt;p&gt;要判断一个单精度浮点数：则是if( abs(f) &amp;lt;= 1e-6)； 要判断一个双精度浮点数：则是if( abs(f) &amp;lt;= 1e-15 )；&lt;/p&gt;
&lt;h4 id=&#34;sizeof是编译时执行还是运行时执行&#34;&gt;sizeof是编译时执行还是运行时执行&lt;/h4&gt;
&lt;p&gt;编译时，即sizeof返回大小为声明类型大小&lt;/p&gt;
&lt;h4 id=&#34;内存泄露的定义如何检测与避免&#34;&gt;内存泄露的定义，如何检测与避免？&lt;/h4&gt;
&lt;p&gt;动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。&lt;/p&gt;
&lt;p&gt;造成内存泄漏的几种原因：&lt;/p&gt;
&lt;p&gt;1）类的构造函数和析构函数中new和delete没有配套&lt;/p&gt;
&lt;p&gt;2）在释放对象数组时没有使用delete[]，使用了delete&lt;/p&gt;
&lt;p&gt;3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露&lt;/p&gt;
&lt;p&gt;检测：&lt;/p&gt;
&lt;p&gt;主要思路就是使每个new和delete匹配上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在new和delete外面多包一层，并替换原有的new和delete运算符，将每次new和delete的信息输入到log中或者print出来，程序运行结束后检查是否每个new的对象都被delete&lt;/li&gt;
&lt;li&gt;重载new和delete，将用new手动分配的内存地址用一个链表连起来，每次delete的时候删除对应地址的节点，最后遍历一遍这个链表，剩下的节点就是泄露的内存地址&lt;/li&gt;
&lt;li&gt;Valgrind（没用过。。。）&lt;/li&gt;
&lt;li&gt;智能指针&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;c内存管理&#34;&gt;C++内存管理&lt;/h4&gt;
&lt;p&gt;BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于静态分配，程序结束后静态变量资源由系统自动释放。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201108193834991.png&#34; alt=&#34;image-20201108193834991&#34;&gt;&lt;/p&gt;
&lt;p&gt;DATA段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于静态内存分配。数据段包含经过初始化的全局变量以及它们的值。DATA段又可分为读写（RW）区域和只读（RO）区域。RO段保存常量；RW段则是普通非常量全局变量，静态变量就在其中&lt;/p&gt;
&lt;p&gt;TEXT段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量&lt;/p&gt;
&lt;p&gt;可执行程序在运行时又多出两个区域：栈区和堆区。&lt;/p&gt;
&lt;p&gt;栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。&lt;/p&gt;
&lt;p&gt;堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。频繁的 malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。&lt;/p&gt;
&lt;h4 id=&#34;给函数传入一个指针参数可以用这个指针申请内存吗&#34;&gt;给函数传入一个指针参数，可以用这个指针申请内存吗&lt;/h4&gt;
&lt;p&gt;不行，传入的指针实际上是一个副本，虽然函数中这个指针和函数外的指针指向的地址相同，但它们是两个指针；当用malloc分配内存时函数内指针指向的地址发生改变，但是却不会影响函数外原来指针指向的地址，当函数结束时函数内的临时参数指针副本会被销毁，导致这块内存无法被找到&lt;/p&gt;
&lt;p&gt;正确的做法是传入指向这个指针的指针来改变这个指针的指向地址，或者让函数直接返回指向新地址的指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201108182314860.png&#34; alt=&#34;image-20201108182314860&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;指针--数组区别&#34;&gt;指针 / 数组区别&lt;/h4&gt;
&lt;p&gt;（除了字符串情况之外）如果要在声明的同时进行初始化，指针需要用new的方式初始化，而数组要用{}的方式初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;// 内存分配在堆上
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    int *n2 = {1,2,3,4,5}; // 指针声明初始化只能用new
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n3[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// 内存分配在栈上
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    int n4[] = new int[5]; // 数组声明初始化只能用显式数组列表
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;n5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n3; &lt;span style=&#34;color:#75715e&#34;&gt;// 指针可以赋值初始化，让它指向一个数组
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//    int n6[] = n1; // 数组却只能显式声明数组列表是什么
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;字符串能不能修改&#34;&gt;字符串能不能修改&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; str[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;;
str[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序可以正常运行，因为这里的hello world是放在栈里面的而不是只读数据区，所以可以进行修改&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;;
str[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序会出现错误，因为这里的hello world是一个字符串常量，放在DATA段并且是只读的，对只读内容进行修改的话会报错&lt;/p&gt;
&lt;p&gt;并且C++11会直接给警告说禁止string literal到char *的转换，而是应该写成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;;
str[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;才可以通过，而现在str是一个const，修改其内容自然是被禁止的了&lt;/p&gt;
&lt;h4 id=&#34;字符串能不能重新赋值&#34;&gt;字符串能不能重新赋值&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; str[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;;
str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Shit&amp;#34;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序是错误的，因为数组是不能重新赋值的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;;
str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Shit&amp;#34;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个程序可以正常运行，因为虽然*str是const，但是str本身不是const，让str指向另一个string literal是合法的操作&lt;/p&gt;
&lt;h4 id=&#34;堆和栈在内存中的区别&#34;&gt;堆和栈在内存中的区别&lt;/h4&gt;
&lt;p&gt;堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收&lt;/p&gt;
&lt;p&gt;栈：由编译器(Compiler)自动分配释放&lt;/p&gt;
&lt;p&gt;堆：操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序；由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中&lt;/p&gt;
&lt;p&gt;栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。&lt;/p&gt;
&lt;p&gt;堆：不连续的内存区域&lt;/p&gt;
&lt;p&gt;栈：连续的内存区域&lt;/p&gt;
&lt;p&gt;堆：是由new分配的内存，一般速度比较慢，而且容易产生内存碎片&lt;/p&gt;
&lt;p&gt;栈：由系统自动分配，速度较快，程序员是无法控制的&lt;/p&gt;
&lt;h4 id=&#34;没有构造对象时能访问成员函数吗&#34;&gt;没有构造对象时能访问成员函数吗&lt;/h4&gt;
&lt;p&gt;原来编译器找成员函数位置是根据声明类型找的么。。。声明时就已经知道了这个对象的类型，所以即使这个对象实际上只是一个空指针，编译器也能找到成员函数的位置并执行；但虚函数的话是运行期才知道函数指针是哪个（虚函数表）不能仅凭声明类型知道成员函数是哪个，所以会异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201030220828266.png&#34; alt=&#34;image-20201030220828266&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;引用和指针的区别&#34;&gt;引用和指针的区别&lt;/h4&gt;
&lt;p&gt;指针指向对象地址，引用可以看作对象的一个别名&lt;/p&gt;
&lt;p&gt;int n = 5; 指针：int *ptr = &amp;amp;n; 引用：int &amp;amp;ref = n;&lt;/p&gt;
&lt;p&gt;指针可以指向NULL，引用不行&lt;/p&gt;
&lt;p&gt;指针可以重新赋值，引用不行&lt;/p&gt;
&lt;p&gt;指针可以在C里使用，引用不行&lt;/p&gt;
&lt;p&gt;指针大小取决于系统是32位还是64位，引用大小为对象大小&lt;/p&gt;
&lt;h4 id=&#34;什么时候使用指针什么时候使用引用&#34;&gt;什么时候使用指针，什么时候使用引用&lt;/h4&gt;
&lt;p&gt;需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的&lt;/p&gt;
&lt;p&gt;对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小&lt;/p&gt;
&lt;h4 id=&#34;malloc和new区别&#34;&gt;malloc和new区别&lt;/h4&gt;
&lt;p&gt;new是C++关键字，malloc是C的库函数&lt;/p&gt;
&lt;p&gt;使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸&lt;/p&gt;
&lt;p&gt;new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型&lt;/p&gt;
&lt;p&gt;new不仅申请内存还调用类的构造函数初始化成员变量，malloc只申请内存&lt;/p&gt;
&lt;p&gt;new失败报异常，malloc失败返回空指针&lt;/p&gt;
&lt;h4 id=&#34;delete和delete区别&#34;&gt;delete和delete[]区别&lt;/h4&gt;
&lt;p&gt;delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数&lt;/p&gt;
&lt;p&gt;用new分配的内存用delete释放，用new[]分配的内存用delete[]释放&lt;/p&gt;
&lt;h4 id=&#34;大端序小端序&#34;&gt;大端序小端序&lt;/h4&gt;
&lt;p&gt;数字11 22 33 44 （4字节），强制转换为字符指针（1字节）&lt;/p&gt;
&lt;p&gt;大端序：低位 -&amp;gt; 高位；小端序：高位 -&amp;gt; 低位&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){

  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x11223344&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) pi;

  printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;%x/n&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pc);

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h4&gt;
&lt;p&gt;如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。&lt;/p&gt;
&lt;p&gt;内存对齐主要遵循下面三个原则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结构体变量的&lt;strong&gt;起始地址&lt;/strong&gt;能够被其最宽的成员大小整除&lt;/li&gt;
&lt;li&gt;结构体每个成员相对于&lt;strong&gt;起始地址的偏移&lt;/strong&gt;能够被其&lt;strong&gt;自身大小整除&lt;/strong&gt;，如果不能则在&lt;strong&gt;前一个成员后面&lt;/strong&gt;补充字节&lt;/li&gt;
&lt;li&gt;结构体总体大小能够&lt;strong&gt;被最宽的成员的大小&lt;/strong&gt;整除，如不能则在&lt;strong&gt;后面&lt;/strong&gt;补充字节&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;类的大小&#34;&gt;类的大小&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;base&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		base()&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;
		&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;base()&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;计算结果：8，静态变量a不计算在对象的大小内；类的大小与构造函数，析构函数，普通成员函数无关；结果为4+4=8（字节对齐）&lt;/p&gt;
&lt;p&gt;注意：类的数据成员按其声明顺序加入内存&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; {};
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(A)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 1;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  A a; 
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(a)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 1;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Empty&lt;/span&gt; {};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HoldsAnInt&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
  Empty e;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这种情况下，空类的1字节是会被计算进去的。而又由于字节对齐的原则，所以结果为4+4=8。&lt;/p&gt;
&lt;p&gt;继承空类的派生类，如果派生类也为空类，大小也都为1。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Fun&lt;/span&gt;(){} };
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(A)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 4(32位机器)/8(64位机器);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  A a; 
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(a)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 4(32位机器)/8(64位机器);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是8字节（64位系统）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; c;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fun&lt;/span&gt;() {}
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; a;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fun&lt;/span&gt;() {}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; b;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;编译器(gcc 和 微软)一般会把虚指针放在类的内存空间的最前面的位置，不管虚函数声明的位置。考虑对齐，大小为8+8=16&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a; };
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(A)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 1;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  A a; 
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(a)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 1;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b; };;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(A)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 4;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  A a; 
  cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(a)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;&lt;span style=&#34;color:#75715e&#34;&gt;// 输出 4;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b;
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码，不同的编译器结果不同，VS的结果是 8 和 12， GCC是8 和 8。VS中 相当于&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;
{
    A a;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A的大小为8，对齐值为4， 则考虑总体对齐 8 + 1 + 3(padding) = 12。
GCC 则是&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; c;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果为 4 + 1 + 1 + 2 = 8。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fun&lt;/span&gt;() {}
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fun2&lt;/span&gt;() {}
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;  A, &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; B
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; fun3() {}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果为 8 8 16。分析：类A一个虚函数表，类B一个虚函数表，类C继承了两个虚函数表，并把自己的虚函数写在了继承顺序中第一个虚函数表中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;D&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; B, C{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结构为4，16，16，40，虚继承的情况下即使没有虚函数也会有一个指向虚基类的指针（但没有指向虚表的指针了，指向虚表的指针是与基类共享的），内存对齐后B和C都是16，D为B+C+int并要跟B，C中的虚指针（8）对齐，结果为40&lt;/p&gt;
&lt;h4 id=&#34;调用的压栈过程&#34;&gt;调用的压栈过程&lt;/h4&gt;
&lt;p&gt;函数的调用过程：&lt;/p&gt;
&lt;p&gt;1）从栈空间分配存储空间&lt;/p&gt;
&lt;p&gt;2）从实参的存储空间复制值到形参栈空间&lt;/p&gt;
&lt;p&gt;3）进行运算&lt;/p&gt;
&lt;p&gt;形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。&lt;/p&gt;
&lt;p&gt;数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。&lt;/p&gt;
&lt;p&gt;当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。&lt;/p&gt;
&lt;h4 id=&#34;可执行文件的生成过程&#34;&gt;可执行文件的生成过程&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;预编译（预编译器处理如 &lt;code&gt;#include&lt;/code&gt;、&lt;code&gt;#define&lt;/code&gt; 等预编译指令，生成 &lt;code&gt;.i&lt;/code&gt; 或 &lt;code&gt;.ii&lt;/code&gt; 文件）&lt;/li&gt;
&lt;li&gt;编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 &lt;code&gt;.s&lt;/code&gt; 文件）&lt;/li&gt;
&lt;li&gt;汇编（汇编器把汇编码翻译成机器码，生成 &lt;code&gt;.o&lt;/code&gt; 文件）&lt;/li&gt;
&lt;li&gt;链接（连接器进行地址和空间分配、符号解析、重定位，生成 &lt;code&gt;.out&lt;/code&gt; 文件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;符号解析&lt;/strong&gt;：目标文件定义和引用符号，符号解析的目的是将每个符号引用和一个符号定义联系起来；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重定位&lt;/strong&gt;：把每个符号定义与一个存储器位置联系起来，然后修改对这些符号的引用，是的他们指向这个存储器位置，从而实现重定位。&lt;/p&gt;
&lt;h4 id=&#34;静态链接和动态链接&#34;&gt;静态链接和动态链接&lt;/h4&gt;
&lt;p&gt;如果函数库的一份拷贝是可执行文件的物理组成部分，称之为静态链接。静态链接当链接程序时，需要使用的每个库函数的一份拷贝被加入到可执行文件中。静态链接使用静态库进行链接，生成的程序包含程序运行所需要的全部库，可以直接运行，不过静态链接生成的程序体积较大（即使是在静态链接中，整个库文件也并没有全部装入到可执行文件中，所装入的只是需要的函数）。&lt;/p&gt;
&lt;p&gt;如果可执行文件只是包含了文件名，让载入器在运行时能够寻找程序所需要的函数库，称之为动态链接。动态链接允许系统提供一个庞大的函数库集合，可以提供许多有用的服务，程序在运行时寻找它们。动态链接使用动态链接库进行链接，外部函数被真正调用之前，运行时载入器并不解析它们。所以动态链接即使链接了函数库，如果没有实际调用，也不会带来额外开销。动态链接生成的程序体积较小，但是必须依赖所需的动态库，否则无法执行。&lt;/p&gt;
&lt;h4 id=&#34;怎么在main函数之前和之后执行代码&#34;&gt;怎么在main函数之前和之后执行代码&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031133827730.png&#34; alt=&#34;image-20201031133827730&#34;&gt;&lt;/p&gt;
&lt;p&gt;全局变量会在main函数执行之前进行初始化，可以利用这一点在main之前执行代码
atexit函数可以注册一个在main函数结束后要调用的函数，atexit注册的函数结束后程序才会真正exit；atexit可以在程序的任意位置调用&lt;/p&gt;
&lt;p&gt;或者通过在全局变量对象的析构函数也能实现在main之后运行函数（main结束后会释放全局变量的内存）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201109141055379.png&#34; alt=&#34;image-20201109141055379&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;被free回收的内存是立即返还给操作系统吗为什么&#34;&gt;被free回收的内存是立即返还给操作系统吗？为什么&lt;/h4&gt;
&lt;p&gt;不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。&lt;/p&gt;
&lt;h4 id=&#34;malloc原理&#34;&gt;malloc原理&lt;/h4&gt;
&lt;p&gt;1、空闲存储空间以&lt;strong&gt;空闲链表&lt;/strong&gt;的方式组织（地址递增），每个块包含一个长度、一个指向下一块的指针以及一个指向自身存储空间的指针。（ 因为程序中的某些地方可能不通过malloc调用申请，因此malloc管理的空间不一定连续。）
2、当有申请请求时，malloc会&lt;strong&gt;扫描空闲链表&lt;/strong&gt;，直到找到一个&lt;strong&gt;足够大的块&lt;/strong&gt;为止（首次适应）(因此每次调用malloc时并不是花费了完全相同的时间）。
3、如果该块恰好与请求的大小相符，则将其从链表中移走并返回给用户。如果该块太大，则将其分为两部分，尾部的部分分给用户，剩下的部分留在空闲链表中（更改头部信息）。因此&lt;strong&gt;malloc分配的是一块连续的内存。&lt;/strong&gt;
4、释放时，首先&lt;strong&gt;搜索空闲链表&lt;/strong&gt;，找到可以&lt;strong&gt;插入被释放块的合适位置&lt;/strong&gt;。如果与被释放块相邻的任一边是一个空闲块，则将这两个块&lt;strong&gt;合为一个更大的块&lt;/strong&gt;，以&lt;strong&gt;减少内存碎片&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;如何定义一个只能在堆上栈上生成对象的类&#34;&gt;如何定义一个只能在堆上（栈上）生成对象的类？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只能在堆上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：将析构函数设置为私有&lt;/p&gt;
&lt;p&gt;原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能在栈上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：将 new 和 delete 重载为私有&lt;/p&gt;
&lt;p&gt;原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。&lt;/p&gt;
&lt;h3 id=&#34;面向对象&#34;&gt;面向对象&lt;/h3&gt;
&lt;h4 id=&#34;oop三大特性&#34;&gt;OOP三大特性&lt;/h4&gt;
&lt;p&gt;封装 ：就是将一个类的使用和实现分开，只保留部分接口和方法与外部联系；private仅本类可见；protected子类可见；public都可见&lt;/p&gt;
&lt;p&gt;继承：子类自动继承其父级类中的属性和方法，并可以添加新的属性和方法或者对部分属性和方法进行重写。继承增加了代码的可重用性&lt;/p&gt;
&lt;p&gt;多态：多个子类中虽然都具有同一个方法，但是这些子类实例化的对象调用这些相同的方法后却可以获得完全不同的结果&lt;/p&gt;
&lt;h4 id=&#34;重载和重写&#34;&gt;重载和重写&lt;/h4&gt;
&lt;p&gt;重载overload：在同一个类中，函数名称相同参数不同，未体现多态&lt;/p&gt;
&lt;p&gt;重写override：也叫覆盖，子类重新定义父类中有相同名称相同参数的虚函数，主要是在继承关系中出现的，被重写的函数必须是virtual的，重写函数的访问修饰符可以不同，尽管virtual是private的，子类中重写函数改为public,protected也可以，体现了多态。&lt;/p&gt;
&lt;h4 id=&#34;c重载时返回值是否可以相同&#34;&gt;c重载时返回值是否可以相同&lt;/h4&gt;
&lt;p&gt;可以相同可以不同，但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载&lt;/p&gt;
&lt;h4 id=&#34;友元函数--友元类&#34;&gt;友元函数 &amp;amp; 友元类&lt;/h4&gt;
&lt;p&gt;友元函数是可以直接访问类的私有成员的非成员函数，是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需在友元的名称前加上关键字friend&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Box&lt;/span&gt;
{
   &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; width;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; printWidth( Box box );
   &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setWidth&lt;/span&gt;( &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; wid );
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printWidth&lt;/span&gt;( Box box )
{
   &lt;span style=&#34;color:#75715e&#34;&gt;/* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */&lt;/span&gt;
   cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Width of box : &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; box.width &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;friend&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;;                         &lt;span style=&#34;color:#75715e&#34;&gt;//这是友元类的声明
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; data;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;             &lt;span style=&#34;color:#75715e&#34;&gt;//友元类定义，为了访问类A中的成员
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; set_show(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, A &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a) { a.data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x; cout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;a.data&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;endl;}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(1) 友元关系不能被继承。&lt;/p&gt;
&lt;p&gt;(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明&lt;/p&gt;
&lt;p&gt;(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明&lt;/p&gt;
&lt;h4 id=&#34;struct和class区别&#34;&gt;struct和class区别&lt;/h4&gt;
&lt;p&gt;使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的&lt;/p&gt;
&lt;p&gt;struct的继承默认是public继承，而class的继承默认是private继承&lt;/p&gt;
&lt;p&gt;class可以用作模板，而struct不能&lt;/p&gt;
&lt;h4 id=&#34;构造函数使用初始化列表和函数中赋值的区别&#34;&gt;构造函数使用初始化列表和函数中赋值的区别&lt;/h4&gt;
&lt;p&gt;注意：Test2构造函数中的参数t1为引用，这样能少一次拷贝行为，如果不是引用而是普通变量的话会把实参拷贝一份再传入构造函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017211432878.png&#34; alt=&#34;image-20201017211432878&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果赋值的话，Test2会先新建一个Test1对象test1，然后通过赋值运算符把参数t1的值复制过去&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017211523694.png&#34; alt=&#34;image-20201017211523694&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果直接初始化列表的话，Test2会直接拷贝一个Test1并设置为自己的成员变量&lt;/p&gt;
&lt;h4 id=&#34;继承&#34;&gt;继承&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;公有&lt;/strong&gt;成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值&lt;/p&gt;
&lt;p&gt;私有成员变量或函数在类的外部是不可访问的，只有类和友元函数可以访问私有成员&lt;/p&gt;
&lt;p&gt;保护成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200903202336092.png&#34; alt=&#34;image-20200903202336092&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;虚函数的目的实现&#34;&gt;虚函数的目的，实现&lt;/h4&gt;
&lt;p&gt;虚函数是一种实现多态的机制：父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数&lt;/p&gt;
&lt;p&gt;在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率&lt;/p&gt;
&lt;h4 id=&#34;纯虚函数--抽象类&#34;&gt;纯虚函数 &amp;amp; 抽象类&lt;/h4&gt;
&lt;p&gt;纯虚函数：没有函数体的虚函数，必须在非抽象类中实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Fun1&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;抽象类：包含纯虚函数的类；只能作为基类来派生新类使用，不能创建抽象类的对象，抽象类的指针和引用 -&amp;gt; 由抽象类派生出来的类的对象。如果一个类从抽象类派生而来 它必须实现了基类中的所有纯虚函数，才能成为非抽象类。抽象类中在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数&lt;/p&gt;
&lt;h4 id=&#34;为什么只能用指针和引用实现多态而对象不可以&#34;&gt;为什么只能用指针和引用实现多态，而对象不可以？&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Base &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Derive();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时会把derive指针bitwise拷贝到base指针里面，所以base指向的是Derive对象，其虚表指针指向的也是Derive类的虚函数表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Base base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Derive();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时会把Derive对象bitwise拷贝到base对象里面，但是C++在拷贝到时候并不会拷贝虚表指针，所以以对象形式赋值之后base的虚表指针指向的仍然是Base类的虚表，所以实现不了多态&lt;/p&gt;
&lt;p&gt;引用某种意义上跟指针也类似，所以也可以实现多态&lt;/p&gt;
&lt;h4 id=&#34;虚继承&#34;&gt;虚继承&lt;/h4&gt;
&lt;p&gt;虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//间接基类A
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_a;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//直接基类B
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{
&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_b;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//直接基类C
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{
&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_c;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//派生类D
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;D&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; B, &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; C{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; seta(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a){ m_a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a; }  &lt;span style=&#34;color:#75715e&#34;&gt;//命名冲突
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setb&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){ m_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c){ m_c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setd&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d){ m_d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_d;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    D d;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码实现了上图所示的菱形继承，第 25 行代码试图直接访问成员变量 m_a，结果发生了错误，因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。&lt;/p&gt;
&lt;p&gt;为了消除歧义，我们可以在 m_a 的前面指明它具体来自哪个类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;seta&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a){ B&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;m_a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//间接基类A
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_a;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//直接基类B
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{  &lt;span style=&#34;color:#75715e&#34;&gt;//虚继承
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_b;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//直接基类C
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;C&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;virtual&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; A{  &lt;span style=&#34;color:#75715e&#34;&gt;//虚继承
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;protected&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_c;
};

&lt;span style=&#34;color:#75715e&#34;&gt;//派生类D
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;D&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; B, &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; C{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; seta(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a){ m_a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setb&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){ m_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; b; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c){ m_c &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; c; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setd&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; d){ m_d &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; d; }  &lt;span style=&#34;color:#75715e&#34;&gt;//正确
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m_d;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    D d;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;子类重写了父类虚方法之后可以调用父类的这个虚方法吗&#34;&gt;子类重写了父类虚方法之后，可以调用父类的这个虚方法吗&lt;/h4&gt;
&lt;p&gt;还真他妈可以。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031183154055.png&#34; alt=&#34;image-20201031183154055&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;虚函数virtual可以是内联函数inline吗&#34;&gt;虚函数（virtual）可以是内联函数（inline）吗？&lt;/h4&gt;
&lt;p&gt;内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。&lt;/p&gt;
&lt;h4 id=&#34;为什么对于存在虚函数的类中析构函数要定义成虚函数&#34;&gt;&lt;strong&gt;为什么对于存在虚函数的类中析构函数要定义成虚函数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200903205957863.png&#34; alt=&#34;image-20200903205957863&#34;&gt;&lt;/p&gt;
&lt;p&gt;（声明为基类指针的子类对象，delete时只调用基类的析构函数，不调用子类析构函数）&lt;/p&gt;
&lt;p&gt;为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为虚函数，则会调用基类的析构函数，显然只能销毁部分数据。如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。&lt;/p&gt;
&lt;h4 id=&#34;static函数为什么不能是虚函数&#34;&gt;static函数为什么不能是虚函数&lt;/h4&gt;
&lt;p&gt;static成员没有this指针，static function都是静态决议的（编译的时候就绑定了）
而virtual function 是动态决议的（运行时候才绑定）&lt;/p&gt;
&lt;h4 id=&#34;构造函数为什么不能是虚函数&#34;&gt;构造函数为什么不能是虚函数&lt;/h4&gt;
&lt;p&gt;在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针&lt;/p&gt;
&lt;h4 id=&#34;那构造函数可以调用虚函数吗&#34;&gt;那构造函数可以调用虚函数吗&lt;/h4&gt;
&lt;p&gt;可以，但这样虚不虚都没区别了&lt;/p&gt;
&lt;p&gt;父类的构造函数中调用的是父类的虚函数，在子类中调用的是子类的虚函数。因为调用父类的构造函数时还没有子类，所以此时会调用父类的虚函数；调用子类的构造函数时有子类了，所以调用的是子类的虚函数&lt;/p&gt;
&lt;h4 id=&#34;构造函数&#34;&gt;构造函数&lt;/h4&gt;
&lt;p&gt;C++中的构造函数主要有四种类型：默认构造函数、重载构造函数，拷贝构造函数，移动构造函数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。&lt;/li&gt;
&lt;li&gt;重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。&lt;/li&gt;
&lt;li&gt;拷贝构造函数是在发生对象复制的时候调用的，例如以调用函数时以对象形式传入参数，或者调用=赋值运算符时&lt;/li&gt;
&lt;li&gt;移动构造函数见右值引用部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200903235617154.png&#34; alt=&#34;image-20200903235617154&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;为什么拷贝构造函数参数需要是引用&#34;&gt;为什么拷贝构造函数参数需要是引用&lt;/h4&gt;
&lt;p&gt;不是引用的话调用拷贝构造函数本身就需要复制参数，要复制参数就需要调拷贝构造函数，尼玛没完了&lt;/p&gt;
&lt;h4 id=&#34;拷贝构造函数参数必须是const吗&#34;&gt;拷贝构造函数参数必须是const吗&lt;/h4&gt;
&lt;p&gt;不是也行，编译器不会拦着你，但是为了安全（拷贝构造函数不应该修改原对象的值）还是加上比较好&lt;/p&gt;
&lt;h4 id=&#34;什么时候调用拷贝构造函数&#34;&gt;什么时候调用拷贝构造函数&lt;/h4&gt;
&lt;p&gt;在C++中，下面三种对象需要调用拷贝构造函数（有时也称“复制构造函数”）：&lt;/p&gt;
&lt;p&gt;　　1) 一个对象作为函数参数，以&lt;strong&gt;值传递&lt;/strong&gt;的方式传入函数体；&lt;/p&gt;
&lt;p&gt;　　2) 一个对象作为函数返回值，以&lt;strong&gt;值传递&lt;/strong&gt;的方式从函数返回；&lt;/p&gt;
&lt;p&gt;　　3) 一个对象用于给另外一个对象进行&lt;strong&gt;初始化&lt;/strong&gt;（常称为&lt;strong&gt;复制初始化&lt;/strong&gt;），即用=运算符赋值时&lt;/p&gt;
&lt;h4 id=&#34;什么时候需要自定义拷贝构造函数&#34;&gt;什么时候需要自定义拷贝构造函数&lt;/h4&gt;
&lt;p&gt;默认的拷贝构造函数是把原对象的二进制内容以bitwise的形式拷贝到新的对象里，有些时候光是拷贝二进制无法满足用户对拷贝构造函数的要求，此时就需要自定义拷贝构造函数&lt;/p&gt;
&lt;p&gt;例如初始化时给了对象Anew了一个指向B对象指针的情况，此时如果把二进制内容直接复制过去会导致原对象和拷贝的对象的指针都指向同样的B对象，而用户可能想两个对象指向不同的B对象，此时就得自定义拷贝构造函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201030220244448.png&#34; alt=&#34;image-20201030220244448&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201030220253390.png&#34; alt=&#34;image-20201030220253390&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;析构函数能抛出异常吗&#34;&gt;&lt;strong&gt;析构函数能抛出异常吗&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。&lt;/p&gt;
&lt;h4 id=&#34;模版&#34;&gt;模版&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200904153017442.png&#34; alt=&#34;image-20200904153017442&#34;&gt;&lt;/p&gt;
&lt;p&gt;在&lt;strong&gt;编译器进行编译的时候&lt;/strong&gt;，编译器会产生类的模板函数的声明，当时实际确认类型后调用的时候，会根据调用的类型进行再次帮我们生成对应类型的函数声明和定义。我们称之为二次编译&lt;/p&gt;
&lt;h4 id=&#34;为什么模板成员函数不能是虚函数&#34;&gt;为什么模板成员函数不能是虚函数&lt;/h4&gt;
&lt;p&gt;当前的编译器都期望在处理类的定义的时候就能确定这个类的虚函数表的大小，如果允许有类的虚成员模板函数，那么就必须要求编译器提前知道程序中所有对该类的该虚成员模板函数的调用，而这是不可行的。&lt;/p&gt;
&lt;h4 id=&#34;为什么模版实现要放在头文件里&#34;&gt;为什么模版实现要放在头文件里&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;C++标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编译器只有同时看到对模版类的定义和调用时才会生成对应包含实际类型的类的定义，但是很遗憾，编译器每次只编译一个cpp文件，如果定义和调用放在两个cpp里面的话，编译器就啥都生成不了。。。&lt;/p&gt;
&lt;p&gt;如果跟普通类一样在头文件中声明，cpp中实现的话，编译器不会生成任何有意义的代码，因为模板类的cpp文件中并没有调用这个模板类，所以编译器生成的.o文件里面不会有这个模版类的可执行代码，实际结果就会像没有模板类的这个cpp文件一样。编译器在main中看到对模版类的调用时，不知道这个模版类的定义是什么，所以会认为链接的时候能够找到一个对应的定义。此时链接编译好的模版类.o文件会发现里面啥都没有，所以会报错&lt;/p&gt;
&lt;p&gt;如果放在头文件里，main函数中用到模板类时由于一开始有include模板类的头文件，所以此时编译器能够找到模板类的实现，并根据实际调用的情况生成正确的的.o文件&lt;/p&gt;
&lt;p&gt;唯一能绕过去的办法就是头文件里面声明，cpp中实现，并且main中要调用哪一种模版就在cpp最后加一行对应的调用，这样编译器发现有要调用这个种类的模板，就会在.o文件中生成对应的可执行代码，链接的时候就可以链接上了&lt;/p&gt;
&lt;p&gt;不过正常人都不会选择这种做法。。。&lt;/p&gt;
&lt;p&gt;模板的本质和宏差不多，就是一系统预定义，不能把它和普通的源文件混淆，所以理所应当的模板实现应该以宏定义一样对待写在头文件里&lt;/p&gt;
&lt;h4 id=&#34;强制类型转换&#34;&gt;强制类型转换&lt;/h4&gt;
&lt;p&gt;四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1）static_cast ：
用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;特性与要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它没有运行时类型检查，所以是有安全隐患的。&lt;/li&gt;
&lt;li&gt;在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题&lt;/li&gt;
&lt;li&gt;static_cast不能转换const，volatile等属性&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2）dynamic_cast：
用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。
dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。
dynamic_cast如果不能转换返回NULL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3）const_cast：
用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4）reinterpret_cast
几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;static_cast 和 reinterpret_cast 操作符修改了操作数类型。它们不是互逆的； static_cast 在编译时使用类型信息执行转换，在转换执行必要的检测(诸如指针越界计算, 类型检查). 其操作数相对是安全的。另一方面；reinterpret_cast 仅仅是重新解释了给出的对象的比特模型而没有进行二进制转换， 例子如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static_cast&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (n); 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的例子中, 我们将一个变量从 int 转换到 double。 这些类型的二进制表达式是不同的。 要将整数 9 转换到 双精度整数 9，static_cast 需要正确地为双精度整数 d 补足比特位。其结果为 9.0。而reinterpret_cast 的行为却不同:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;; 
&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; d&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;reinterpret_cast&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (n);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在进行计算以后, d 包含无用值. 这是因为 reinterpret_cast 仅仅是复制 n 的比特位到 d, 没有进行必要的分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200904232256093.png&#34; alt=&#34;image-20200904232256093&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;stl&#34;&gt;STL&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器&lt;/th&gt;
&lt;th&gt;底层数据结构&lt;/th&gt;
&lt;th&gt;时间复杂度&lt;/th&gt;
&lt;th&gt;有无序&lt;/th&gt;
&lt;th&gt;可不可重复&lt;/th&gt;
&lt;th&gt;其他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#array&#34;&gt;array&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;随机读改 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;支持随机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#vector&#34;&gt;vector&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;支持随机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#deque&#34;&gt;deque&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双端队列&lt;/td&gt;
&lt;td&gt;头尾插入、头尾删除 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#forward_list&#34;&gt;forward_list&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;单向链表&lt;/td&gt;
&lt;td&gt;插入、删除 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;不支持随机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#list&#34;&gt;list&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;双向链表&lt;/td&gt;
&lt;td&gt;插入、删除 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;不支持随机访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#stack&#34;&gt;stack&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;deque / list&lt;/td&gt;
&lt;td&gt;顶部插入、顶部删除 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#queue&#34;&gt;queue&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;deque / list&lt;/td&gt;
&lt;td&gt;尾部插入、头部删除 O(1)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#priority_queue&#34;&gt;priority_queue&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;vector + max-heap&lt;/td&gt;
&lt;td&gt;插入、删除 O(log2n)&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;vector容器+heap处理规则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#set&#34;&gt;set&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(log2n)&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;不可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#multiset&#34;&gt;multiset&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(log2n)&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#map&#34;&gt;map&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(log2n)&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;不可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#multimap&#34;&gt;multimap&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;红黑树&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(log2n)&lt;/td&gt;
&lt;td&gt;有序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#unordered_set&#34;&gt;unordered_set&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;哈希表&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(1) 最差 O(n)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;不可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#unordered_multiset&#34;&gt;unordered_multiset&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;哈希表&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(1) 最差 O(n)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#unordered_map&#34;&gt;unordered_map&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;哈希表&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(1) 最差 O(n)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;不可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/huihut/interview/tree/master/STL#unordered_multimap&#34;&gt;unordered_multimap&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;哈希表&lt;/td&gt;
&lt;td&gt;插入、删除、查找 O(1) 最差 O(n)&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;可重复&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;array底层原理&#34;&gt;array底层原理&lt;/h4&gt;
&lt;p&gt;array 与内置数组类似，大小是固定的，因此不支持增加元素、删除元素以及改变容器大小的功能。 在使用 array 时，必须同时指定元素类型和大小&lt;code&gt;array&amp;lt;int,20&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此容器是一个聚合类型，其语义等同于保有一个 C 风格数组 T[N] 作为其唯一非静态数据成员的结构体。该结构体结合了 C 风格数组的性能、可访问性与容器的优点，比如可获取大小、支持赋值、随机访问迭代器等。&lt;/p&gt;
&lt;h4 id=&#34;vector底层原理&#34;&gt;vector底层原理&lt;/h4&gt;
&lt;p&gt;vector底层是一个&lt;strong&gt;动态数组&lt;/strong&gt;，储存空间连续；包含三个迭代器，start和finish之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。&lt;/p&gt;
&lt;p&gt;vector的size属性等于finish-start，表示当前vector中有多少元素；而capacity属性等于end_of_storage-start，表示当前vector分配的内存可以容纳多少元素&lt;/p&gt;
&lt;p&gt;当空间不够装下数据（vec.push_back(val)）时，会自动申请另一片更大的空间，然后把原来的数据拷贝到新的内存空间，接着释放原来的那片空间；对vector的任何操作一旦引起了空间的重新配置**，指向原vector的所有**迭代器会都失效了&lt;/p&gt;
&lt;p&gt;当释放或者删除（vec.clear()）里面的数据时，其存储空间不释放，仅仅是清空了里面的数据。&lt;/p&gt;
&lt;h4 id=&#34;vector动态扩容的机制&#34;&gt;vector动态扩容的机制&lt;/h4&gt;
&lt;p&gt;push_back（只从屁股插入一个数据 ）一般按两倍来扩容&lt;/p&gt;
&lt;p&gt;insert（从迭代器位置插入数据，可插入多个）触发扩容时，如果要插入的数据量比旧容量小，则按两倍扩容；如果要插入的数据量比原来的旧容量还要大，即表示即使按两倍扩容了，依然存不下要插入的数据，此时将会按照旧容量加要插入的数据量来扩容，保证一次扩容就能容下要插入的数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住扩容后vector还得把原来的元素一个一个复制到新地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201101154950990.png&#34; alt=&#34;image-20201101154950990&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;vector中reserve和resize的区别&#34;&gt;vector中reserve和resize的区别&lt;/h4&gt;
&lt;p&gt;reserve会对vector的capacity进行调整，但是size不会变，扩充的内存并没有初始化，直接用[]访问可能会出错&lt;/p&gt;
&lt;p&gt;resize即调整capacity也调整size，并且会往里填充对应类型的对象（resize传入第二个参数val时会把多出来的空间都用val填充，没传入的话就填入默认初始化的对象）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201101142954449.png&#34; alt=&#34;image-20201101142954449&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;vector的元素类型可以是引用吗&#34;&gt;vector的元素类型可以是引用吗？&lt;/h4&gt;
&lt;p&gt;vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用&lt;/p&gt;
&lt;h4 id=&#34;vector迭代器失效的情况&#34;&gt;vector迭代器失效的情况&lt;/h4&gt;
&lt;p&gt;当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。&lt;/p&gt;
&lt;p&gt;当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要用erase方法&lt;/p&gt;
&lt;h4 id=&#34;vector删除元素&#34;&gt;vector删除元素&lt;/h4&gt;
&lt;p&gt;erase方法会删除迭代器指向的元素，并且返回指向下一个元素的迭代器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; iter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;veci.begin(); iter&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;veci.end(); iter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;iter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) veci.erase(iter);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样使用是错误的，因为earase结束后，iter变成了野指针，iter++就产生了错误&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; iter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;veci.begin(); iter&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;veci.end(); iter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;){
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;iter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) iter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; veci.erase(iter);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样也是错误的，因为当vector有两个连续的3时，遇到第一个3会用erase删除第一个3，并返回指向第二个3的迭代器，继续下一个循环时这个迭代器++，会指向下一个元素，这样就删不掉第二个3了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; iter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;veci.begin(); iter&lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt;veci.end()){
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;( &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;iter &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;) iter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; veci.erase(iter);
  		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; iter&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样进入下一个循环时，如果当前元素是3则迭代器不会++，下一个循环的迭代器指向第二个3并进入if判断，第二个3被正常删除；当前元素不是3则正常++&lt;/p&gt;
&lt;h4 id=&#34;vector释放内存&#34;&gt;vector释放内存&lt;/h4&gt;
&lt;p&gt;vec.clear()：清空内容，但是不释放内存（capacity不变）&lt;/p&gt;
&lt;p&gt;vec.shrink_to_fit()：请求容器降低其capacity使其和size相同&lt;/p&gt;
&lt;p&gt;vec.clear(); vec.shrink_to_fit();：清空内容，且释放内存。&lt;/p&gt;
&lt;p&gt;骚操作：vector&lt;!-- raw HTML omitted --&gt;().swap(vec)也可以清空内容，且释放内存&lt;/p&gt;
&lt;p&gt;swap方法的原理是交换两个vector的内部指针以达到“交换整个容器”的效果，所以在和默认的临时变量swap后，成员变量_managedObjectArray确实是个空的容器（包括内存），&lt;/p&gt;
&lt;p&gt;而获得原来vector指针的临时变量会在函数结束时析构，而vector正是在其析构函数中释放内存的，所以在函数结束时，原来指针指向的vector中多余的内存都被释放&lt;/p&gt;
&lt;h4 id=&#34;list的底层原理&#34;&gt;list的底层原理&lt;/h4&gt;
&lt;p&gt;list的底层是一个&lt;strong&gt;双向链表&lt;/strong&gt;，以结点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就配置或释放一个元素空间。插入删除效率都很高（不管是头尾还是中间）因为只需要插入一个节点，不像vector一样要考虑扩容和移动元素&lt;/p&gt;
&lt;p&gt;list不支持随机访问某个位置的元素，只能从头尾一个一个找过去，即不支持[]操作符，也没有vector.at()这样的方法&lt;/p&gt;
&lt;h4 id=&#34;forward_list的底层原理&#34;&gt;forward_list的底层原理&lt;/h4&gt;
&lt;p&gt;forward_list 底层实现上是单链表，且实质上无任何多余开销，与 list 相比，此容器在不需要双向迭代时提供更有效地利用空间的存储。forward_list 的迭代器不支持iter&amp;ndash;操作（即不支持反向迭代），同时 forward_list 也不支持size()操作。&lt;/p&gt;
&lt;h4 id=&#34;deque的底层原理&#34;&gt;deque的底层原理&lt;/h4&gt;
&lt;p&gt;deque是一个双端队列，&lt;strong&gt;存储空间连续&lt;/strong&gt;；在头尾两端进行元素的插入跟删除操作都有理想的时间复杂度，并且支持快速的随机访问；但在中间添加删除元素代价很大，而且占用内存也多&lt;/p&gt;
&lt;p&gt;deque可以直接用push_front, push_back, pop_front, pop_back从头尾添加删除元素&lt;/p&gt;
&lt;p&gt;deque还可以直接用at随机访问某个位置的元素（list就做不到）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deque的实现方式：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和 vector 容器采用连续的线性空间不同，deque 容器存储数据的空间是由一段一段等长的连续空间构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。&lt;/p&gt;
&lt;p&gt;为了管理这些连续空间，deque 容器用数组（数组名假设为 map）存储着各个连续空间的首地址。也就是说，map 数组中存储的都是&lt;a href=&#34;http://c.biancheng.net/c/80/&#34;&gt;指针&lt;/a&gt;，指向那些真正用来存储数据的各个连续空间&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201106153453485.png&#34; alt=&#34;image-20201106153453485&#34;&gt;&lt;/p&gt;
&lt;p&gt;通过建立 map 数组，deque 容器申请的这些分段的连续空间就能实现“整体连续”的效果。换句话说，当 deque 容器需要在头部或尾部增加存储空间时，它会申请一段新的连续空间，同时在 map 数组的开头或结尾添加指向该空间的指针，由此该空间就串接到了 deque 容器的头部或尾部。&lt;/p&gt;
&lt;h4 id=&#34;stack--queue底层原理&#34;&gt;stack / queue底层原理&lt;/h4&gt;
&lt;p&gt;STL的stack和queue就是deque/list封装了一下&lt;/p&gt;
&lt;h4 id=&#34;priority_queue的底层原理&#34;&gt;priority_queue的底层原理&lt;/h4&gt;
&lt;p&gt;priority_queue&amp;lt;Type, Container, Functional&amp;gt;&lt;/p&gt;
&lt;p&gt;Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。&lt;/p&gt;
&lt;p&gt;如果不写后两个参数，那么容器默认用的是std::vector&amp;lt;&amp;gt;，比较方式默认用std::less&lt;!-- raw HTML omitted --&gt;，也就是优先队列是大顶堆，队头元素最大。如果要小顶堆则第三个模版参数填std::greater&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;（greater和less需要先#include &lt;!-- raw HTML omitted --&gt;）&lt;/p&gt;
&lt;p&gt;如果要自定义比较方式就得自己写一个重载了bool operator()的comparator结构体传进去&lt;/p&gt;
&lt;h4 id=&#34;vectordequelist&#34;&gt;vector，deque，list&lt;/h4&gt;
&lt;p&gt;vector：连续存储结构，每个元素在内存上是连续的；支持高效的随机访问和在尾端插入/删除操作，但其他位置的插入/删除操作效率低下；相当于一个数组，但是与数组的区别为：内存空间的扩展&lt;/p&gt;
&lt;p&gt;deque：双端队列，连续存储结构，即其每个元素在内存上也是连续的，类似于vector，不同之处在于deque除了具有vector尾端插入/删除操作外，还支持高效的首端插入/删除操作。&lt;/p&gt;
&lt;p&gt;list：非连续存储结构，具有双链表结构，每个元素维护一对前向和后向指针，因此支持前向/后向遍历。支持高效的随机插入/删除操作，但随机访问效率低下&lt;/p&gt;
&lt;h4 id=&#34;mapsetmultisetmultimap的底层原理&#34;&gt;map，set，multiset，multimap的底层原理&lt;/h4&gt;
&lt;p&gt;都是红黑树，内部元素有序&lt;/p&gt;
&lt;p&gt;multiset和multimap允许相同元素/相同key，map和set不允许&lt;/p&gt;
&lt;p&gt;set不能直接改变元素的值，只能先删除旧元素再添加新元素&lt;/p&gt;
&lt;p&gt;map可以通过key改变value&lt;/p&gt;
&lt;h4 id=&#34;为什么map和set的插入删除效率比用其他序列容器高&#34;&gt;为什么map和set的插入删除效率比用其他序列容器高?&lt;/h4&gt;
&lt;p&gt;对于关联容器来说，不需要做内存拷贝和内存移动。map和set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点&lt;/p&gt;
&lt;h4 id=&#34;为什么map--set每次insert之后以前保存的iterator不会失效&#34;&gt;为什么map / set每次insert之后，以前保存的iterator不会失效?&lt;/h4&gt;
&lt;p&gt;内存位置没变。。。只是红黑树中各节点互相指向的关系变了，但指针指向的地址仍然是有效的&lt;/p&gt;
&lt;h4 id=&#34;unordered_mapunordered_setunordered_multisetunordered_multimap的底层原理&#34;&gt;unordered_map，unordered_set，unordered_multiset，unordered_multimap的底层原理&lt;/h4&gt;
&lt;p&gt;哈希表版本的map，set，multiset，multimap，内部元素无序，内存消耗较大&lt;/p&gt;
&lt;h4 id=&#34;stl中的sort算法是用什么实现的stable_sort呢&#34;&gt;STL中的sort()算法是用什么实现的，stable_sort()呢&lt;/h4&gt;
&lt;p&gt;STL中的sort()在数据量大时，采用快排quicksort，分段递归；一旦分段后的数量小于某个门限值，改用插入排序Insertion sort，避免quicksort深度递归带来的过大的额外负担，如果递归层次过深，还会改用heapsort(堆排序)，stable_sort()是归并排序。&lt;/p&gt;
&lt;h4 id=&#34;push和emplace区别&#34;&gt;push和emplace区别&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201101170718643.png&#34; alt=&#34;image-20201101170718643&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201101170829017.png&#34; alt=&#34;image-20201101170829017&#34;&gt;&lt;/p&gt;
&lt;p&gt;emplace会把一个右值直接move过去，而不是像push一样复制过去
Note：如果是emplace&lt;!-- raw HTML omitted --&gt;({})的话效果一样，也是先调用构造函数再move过去&lt;/p&gt;
&lt;h3 id=&#34;多线程&#34;&gt;多线程&lt;/h3&gt;
&lt;h4 id=&#34;c有哪些锁&#34;&gt;C++有哪些锁&lt;/h4&gt;
&lt;p&gt;互斥锁：pthread_mutex_t&lt;/p&gt;
&lt;p&gt;条件变量：pthread_cond_t&lt;/p&gt;
&lt;p&gt;自旋锁：pthread_spin_lock&lt;/p&gt;
&lt;p&gt;读写锁：pthread_rwlock_t&lt;/p&gt;
&lt;h3 id=&#34;c关键字&#34;&gt;C++关键字&lt;/h3&gt;
&lt;h4 id=&#34;const关键字&#34;&gt;const关键字&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;变量声明使用const：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;const int *p与int const *p相同：*p表示的值不能更改，但可以更改p指向的地址或者通过const int *p = &amp;amp;a; a = 3; 更改&lt;/p&gt;
&lt;p&gt;int *const p：p表示的地址不能更改，不能通过p = &amp;amp;n更改p指向的地址，但可以更改这个地址存放的数据&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;函数前后使用const&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前面使用const表示返回值为const，后面加 const表示函数不可以修改class的成员&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;参数使用const：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不能改变这个作为参数的指针指向的对象&lt;/p&gt;
&lt;h4 id=&#34;const成员变量必须在构造函数中通过-member-的方式初始化&#34;&gt;const成员变量必须在构造函数中通过 :member() 的方式初始化&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017213447679.png&#34; alt=&#34;image-20201017213447679&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意用const修饰成员变量时必须要在构造函数中用初始化列表的方式初始化（声明时初始化也行，但这样会导致所以这个类的实例中这个成员变量的值都一样并且无法改变）&lt;/p&gt;
&lt;p&gt;原因很简单，因为这个成员变量是const，所以不能用赋值的方式（=）给常量赋值，而初始化列表的方式不会涉及赋值只会将传入参数拷贝一份给const成员变量（例子见下）&lt;/p&gt;
&lt;h4 id=&#34;define和const的联系与区别&#34;&gt;define和const的联系与区别&lt;/h4&gt;
&lt;p&gt;define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。&lt;/p&gt;
&lt;p&gt;define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。&lt;/p&gt;
&lt;p&gt;define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。&lt;/p&gt;
&lt;p&gt;const可以定义函数而define不可以。&lt;/p&gt;
&lt;h4 id=&#34;extern关键字&#34;&gt;extern关键字&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919135311891.png&#34; alt=&#34;image-20200919135311891&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于没有#include &amp;ldquo;func.h&amp;rdquo;，必须用extern表示变量/函数在main.c之外的文件中声明过&lt;/p&gt;
&lt;p&gt;extern表示变量/函数在其它文件中声明过了&lt;/p&gt;
&lt;h4 id=&#34;static关键字&#34;&gt;static关键字&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;静态成员变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;静态成员变量是该类的所有对象所共有的。对于普通成员变量，每个类对象都有自己的一份拷贝。而静态成员变量一共就一份，无论这个类的对象被定义了多少个，静态成员变量只分配一次内存，由该类的所有对象共享访问。&lt;/p&gt;
&lt;p&gt;因为静态数据成员在全局数据区分配内存，由本类的所有对象共享，所以，它不属于特定的类对象，不占用对象的内存，而是在所有对象之外开辟内存，在没有产生类对象时其作用域就可见。因此，在没有类的实例存在时，静态成员变量就已经存在，我们就可以操作它；&lt;/p&gt;
&lt;p&gt;静态成员变量存储在全局数据区。static 成员变量的内存空间既不是在声明类时分配，也不是在创建对象时分配，而是在初始化时分配。静态成员变量必须初始化，而且只能在类体外进行（并且声明时要加static成员变量类型）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017210647896.png&#34; alt=&#34;image-20201017210647896&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但static const或const static需要在类体内声明时初始化&lt;/strong&gt;，在构造函数中或类外初始化都会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017205019584.png&#34; alt=&#34;image-20201017205019584&#34;&gt;&lt;/p&gt;
&lt;p&gt;类的静态成员变量访问形式1：＜类对象名＞.＜静态数据成员名＞ ；类的静态成员变量访问形式2：＜类类型名＞::＜静态数据成员名＞，也即，静态成员不需要通过对象就能访问。&lt;/p&gt;
&lt;p&gt;静态数据成员和普通数据成员一样遵从public,protected,private访问规则；&lt;/p&gt;
&lt;p&gt;sizeof 运算符不会计算静态成员变量&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;静态成员函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;静态成员之间可以相互访问，即静态成员函数仅可以访问静态成员变量、静态成员函数，不能访问非静态成员函数和非静态成员变量；&lt;/p&gt;
&lt;p&gt;非静态成员函数可以任意地访问静态成员函数和静态数据成员；&lt;/p&gt;
&lt;p&gt;由于没有this指针的额外开销，静态成员函数与类的全局函数相比速度上会稍快；&lt;/p&gt;
&lt;p&gt;调用静态成员函数，两种方式：通过成员访问操作符(.)和(-&amp;gt;)，也即通过类对象或指向类对象的指针调用静态成员函数；直接通过类来调用静态成员函数。＜类名＞::＜静态成员函数名＞（＜参数表＞）&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;静态全局变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该变量在全局数据区分配内存；&lt;/p&gt;
&lt;p&gt;未经初始化的静态全局变量会被程序自动初始化为0（自动变量的自动初始化值是随机的）；&lt;/p&gt;
&lt;p&gt;静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的（其它文件中可以定义相同名字的变量，不会发生冲突）&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;静态局部变量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常，在函数体内定义了一个变量，每当程序运行到该语句时都会给该局部变量分配栈内存。但随着程序退出函数体，系统就会收回栈内存，局部变量也相应失效。&lt;/p&gt;
&lt;p&gt;但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，这给程序的维护带来不便。&lt;/p&gt;
&lt;p&gt;静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。&lt;/p&gt;
&lt;p&gt;静态局部变量在全局数据区分配内存；&lt;/p&gt;
&lt;p&gt;静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；&lt;/p&gt;
&lt;p&gt;静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0；&lt;/p&gt;
&lt;p&gt;静态局部变量始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束；&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;静态函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在函数的返回类型前加上static关键字,函数即被定义为静态函数。静态函数与普通函数不同，它只能在声明它的文件当中可见，不能被其它文件使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201112143939468.png&#34; alt=&#34;image-20201112143939468&#34;&gt;&lt;/p&gt;
&lt;p&gt;静态全局/成员变量在main开始前初始化，main结束后销毁&lt;/p&gt;
&lt;p&gt;静态局部变量在运行到定义的那一行时初始化，main结束后销毁&lt;/p&gt;
&lt;h4 id=&#34;为什么静态方法不能调用非静态变量&#34;&gt;为什么静态方法不能调用非静态变量&lt;/h4&gt;
&lt;p&gt;静态方法被调用时如果要调用非静态变量就需要对象先被生成，但静态方法却可以在没生成对象时被调用，此时访问成员变量肯定会出错，所以不可以&lt;/p&gt;
&lt;h4 id=&#34;volatile关键字&#34;&gt;volatile关键字&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200904225321320.png&#34; alt=&#34;image-20200904225321320&#34;&gt;&lt;/p&gt;
&lt;p&gt;例如多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：&lt;/p&gt;
&lt;h4 id=&#34;explict关键字&#34;&gt;explict关键字&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;的作用是用来声明类构造函数是显示调用的，而非隐式调用，所以只用于修饰单参构造函数。因为无参构造函数和多参构造函数本身就是显示调用的。再加上&lt;code&gt;explicit&lt;/code&gt;关键字也没有什么意义。&lt;/p&gt;
&lt;p&gt;explict只能用来修饰类构造函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Explicit&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the size is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; str){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string _str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str;
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the str is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; _str &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Explicit&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ins){
     	 std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; The Explicit is ins&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a,&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the a is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the b is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    Explicit test0(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;);
    Explicit test1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;&lt;span style=&#34;color:#75715e&#34;&gt;// 隐式调用Explicit(int size)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    Explicit test2(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;RIGHTRIGHT&amp;#34;&lt;/span&gt;);
    Explicit test3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BUGBUGBUG&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#75715e&#34;&gt;// 隐式调用Explicit(const char* str)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    Explicit test4(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
    Explicit test5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; test1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面的程序虽然没有错误，但是对于&lt;code&gt;Explicit test1 = 10;&lt;/code&gt;和&lt;code&gt;Explicit test2 = &amp;quot;BUGBUGBUG&amp;quot;;&lt;/code&gt;这样的句子，把一个&lt;code&gt;int&lt;/code&gt;类型或者&lt;code&gt;const char*&lt;/code&gt;类型的变量赋值给&lt;code&gt;Explicit&lt;/code&gt;类型的变量看起来总归不是很好，并且当程序很大的时候出错之后也不容易排查。所以为了禁止上面那种隐式转换可能带来的风险，一般都把类的单参构造函数声明的显示调用的，就是在构造函数加关键字``explicit`。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;cstring&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Explicit&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;explicit&lt;/span&gt; Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; size){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the size is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;explicit&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Explicit&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; str){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string _str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; str;
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the str is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; _str &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Explicit&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ins){
     	 std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; The Explicit is ins&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
    Explicit(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a,&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; b){
      	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the a is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; a  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; the b is &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    }
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    Explicit test0(&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;);
    Explicit test1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;&lt;span style=&#34;color:#75715e&#34;&gt;// 无法调用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    Explicit test2(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;RIGHTRIGHT&amp;#34;&lt;/span&gt;);
    Explicit test3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;BUGBUGBUG&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 无法调用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    Explicit test4(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
    Explicit test5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; test
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;inline关键字&#34;&gt;inline关键字&lt;/h4&gt;
&lt;p&gt;inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline&lt;/strong&gt; 必须与函数定义体放在一起才能使函数成为内联，仅将 &lt;strong&gt;inline&lt;/strong&gt; 放在函数声明前面不起任何作用。&lt;/p&gt;
&lt;p&gt;在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数；如果在类声明中未给出成员函数定义，而又想内联该函数的话，那在类外要加上 &lt;strong&gt;inline&lt;/strong&gt;，否则就认为不是内联的。&lt;/p&gt;
&lt;p&gt;内联是以**代码膨胀（复制）**为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。
如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。&lt;/p&gt;
&lt;h4 id=&#34;包含了循环分支的函数不能设为内联吗&#34;&gt;包含了循环，分支的函数不能设为内联吗&lt;/h4&gt;
&lt;p&gt;inline只是个建议，所以循环，分支，递归的函数可以加inline，但是实际上编译器不会内联（复杂函数内联代价比较大）&lt;/p&gt;
&lt;h4 id=&#34;inline和define区别&#34;&gt;inline和define区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内联函数在编译时展开，而宏在预编译时展开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式&lt;/h3&gt;
&lt;h4 id=&#34;c单例模式&#34;&gt;C++单例模式&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    A(){}
    &lt;span style=&#34;color:#75715e&#34;&gt;// C++中如果要求一个类能被复制需要实现赋值运算符或者复制构造函数，设置成私有并删除以防拷贝
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	  A(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 删除拷贝构造函数
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 删除 = 号赋值运算符（运算符重载）
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;A(){}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; instance; &lt;span style=&#34;color:#75715e&#34;&gt;// static member so only one instance
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;// static getInstance method so it can be called withont an actual instance of A
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; A &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;getInstance(){ 
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;){
            A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; A();
        }
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance;
    }
};

&lt;span style=&#34;color:#75715e&#34;&gt;// 饿汉版：程序开始的时候就将instance赋值为A类对象指针，线程安全
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;A&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;getInstance();

&lt;span style=&#34;color:#75715e&#34;&gt;// 懒汉版：一开始将instance赋值为空指针，要用的时候再赋值为A类对象指针，线程不安全
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// A *A::instance = nullptr; 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){
    A &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;getInstance();
    A &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;getInstance();
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (a1 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; a2) cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Same instance&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl; &lt;span style=&#34;color:#75715e&#34;&gt;// Same instance
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;懒汉版线程安全单例&#34;&gt;懒汉版线程安全单例&lt;/h4&gt;
&lt;p&gt;懒汉单例是&lt;strong&gt;非线程安全&lt;/strong&gt;的：假设两个线程同时首次调用该类的静态方法instance()，即它们会同时判断p指针是否指向NULL，则这两个线程会各自实例p指针，出现错误。&lt;/p&gt;
&lt;p&gt;解决方法是初始化单例时同时初始化一个互斥锁，并且getInstance函数中先给互斥锁加锁，然后再判断是否已经有了单例，最后解锁互斥锁&lt;/p&gt;
&lt;h4 id=&#34;设计一个不能拷贝的类&#34;&gt;设计一个不能拷贝的类&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NoCopy&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    NoCopy() {}

&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    NoCopy(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; NoCopy &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;copy) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;
    NoCopy &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; NoCopy &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;copy) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    NoCopy a;
    NoCopy b;
    b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a; &lt;span style=&#34;color:#75715e&#34;&gt;// error: &amp;#39;operator=&amp;#39; is a private member of &amp;#39;NoCopy&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;c11&#34;&gt;C++11&lt;/h3&gt;
&lt;h4 id=&#34;nullptr关键字-c11&#34;&gt;nullptr关键字 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;nullptr&lt;/code&gt; 出现的目的是为了替代 &lt;code&gt;NULL&lt;/code&gt;。在某种意义上来说，传统 C++ 会把 &lt;code&gt;NULL&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt; 视为同一种东西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 &lt;code&gt;((void*)0)&lt;/code&gt;，有些则会直接将其定义为 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，C++11 引入了 &lt;code&gt;nullptr&lt;/code&gt; 关键字，专门用来区分空指针、0。&lt;code&gt;nullptr&lt;/code&gt; 的类型为 &lt;code&gt;nullptr_t&lt;/code&gt;，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。&lt;/p&gt;
&lt;h4 id=&#34;constexpr关键字-c11&#34;&gt;constexpr关键字 (C++11)&lt;/h4&gt;
&lt;p&gt;C++11 提供了 &lt;code&gt;constexpr&lt;/code&gt; 让用户显式的声明函数或对象构造函数在编译期会成为常数，这个关键字明确的告诉编译器应该去验证 &lt;code&gt;len_foo&lt;/code&gt; 在编译器就应该是一个常数。&lt;/p&gt;
&lt;p&gt;C++14中constexptr 函数可以在内部使用局部变量、递归、循环和分支等简单语句&lt;/p&gt;
&lt;h4 id=&#34;default--delete关键字-c11&#34;&gt;default &amp;amp; delete关键字 (C++11)&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Magic&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    Magic() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 显式声明使用编译器生成的构造
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Magic&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Magic&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// 显式声明拒绝编译器生成构造
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Magic(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; magic_number);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;auto关键字-c11&#34;&gt;auto关键字 (C++11)&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 由于 cbegin() 将返回 vector&amp;lt;int&amp;gt;::const_iterator 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 所以 itr 也应该是 vector&amp;lt;int&amp;gt;::const_iterator 类型
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; itr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec.cbegin(); itr &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; vec.cend(); &lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;itr);

&lt;span style=&#34;color:#75715e&#34;&gt;// C++14 开始是可以直接让普通函数具备返回值推导
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T, &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; U&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; add(T x, U y) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;auto还可以用于简化迭代&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 没有auto时的迭代方式：使用迭代器
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * std::vector&amp;lt;int&amp;gt; arr(5, 100);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * for(std::vector&amp;lt;int&amp;gt;::iterator i = arr.begin(); i != arr.end(); ++i) {
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * std::cout &amp;lt;&amp;lt; *i &amp;lt;&amp;lt; std::endl;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * }
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// &amp;amp; 启用了引用, 如果没有则对 arr 中的元素只能读取不能修改
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;i : arr) {    
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;decltype关键字-c11&#34;&gt;decltype关键字 (C++11)&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y) z;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;初始化列表-c11&#34;&gt;初始化列表 (C++11)&lt;/h4&gt;
&lt;p&gt;C++98：普通数组、POD （plain old data，没有构造、析构和虚函数的类或结构体）类型都可以使用 &lt;code&gt;{}&lt;/code&gt; 进行初始化，也就是我们所说的初始化列表。而对于类对象的初始化，要么需要通过拷贝构造、要么就需要使用 &lt;code&gt;()&lt;/code&gt; 进行&lt;/p&gt;
&lt;p&gt;C++11：允许构造函数或其他函数像参数一样使用初始化列表&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C++98
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, m;
};


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    T t1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// OK for compiling
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    T t2{&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// expected &amp;#39;;&amp;#39; at end of declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;POD类型时可以使用&lt;code&gt;T t1 = {12, 123}&lt;/code&gt;的方式进行初始化&lt;/p&gt;
&lt;p&gt;C++98不支持&lt;code&gt;T t2{12, 123}&lt;/code&gt;这样的语句，故不能这样初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C++98
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, m;

    T(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m;
    }
};


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    T t1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// non-aggregate type &amp;#39;T&amp;#39; cannot be initialized with an initializer list
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    T t2{&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// no matching constructor for initialization of &amp;#39;T&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    T t3(&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// OK for compiling
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有构造函数之后不再是POD类型，两种列表初始化的方式都不行，只能用构造函数的方式初始化&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// C++11
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt; {
&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, m;

    T(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; n;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; m;
    }

&lt;span style=&#34;color:#75715e&#34;&gt;//    int foo(){}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    T t1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// OK for compiling
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    T t2{&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;// OK for compiling
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    T t3(&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// OK for compiling
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++11支持即使有构造函数的非POD类型也可以列表初始化，如t1；并且提供了t2所示的语法，提供了统一的语法来初始化任意的对象（把t1和t3的语法融合为t2的方式）&lt;/p&gt;
&lt;h4 id=&#34;尖括号-c11&#34;&gt;尖括号 (C++11)&lt;/h4&gt;
&lt;p&gt;在传统 C++ 的编译器中，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;一律被当做右移运算符来进行处理；这在传统C++编译器下是不能够被编译的，而 C++11 开始，连续的右尖括号将变得合法，并且能够顺利通过编译&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v1(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
    vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;vector &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; v2; &lt;span style=&#34;color:#75715e&#34;&gt;// legal in C++11
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    v2.push_back(v1);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;变长参数模板-c11&#34;&gt;变长参数模板 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919152853236.png&#34; alt=&#34;image-20200919152853236&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;委托构造--继承构造-c11&#34;&gt;委托构造 &amp;amp; 继承构造 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919155139599.png&#34; alt=&#34;image-20200919155139599&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919155147809.png&#34; alt=&#34;image-20200919155147809&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;override--final关键字-c11&#34;&gt;override &amp;amp; final关键字 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919155841816.png&#34; alt=&#34;image-20200919155841816&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919155812072.png&#34; alt=&#34;image-20200919155812072&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919155820570.png&#34; alt=&#34;image-20200919155820570&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;using关键字-c11&#34;&gt;using关键字 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919165948292.png&#34; alt=&#34;image-20200919165948292&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;强枚举类型-c11&#34;&gt;强枚举类型 (C++11)&lt;/h4&gt;
&lt;p&gt;在传统 C++中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类型可以进行直接的比较（虽然编译器给出了检查，但并非所有），&lt;strong&gt;甚至枚举类型的枚举值名字不能相同&lt;/strong&gt;，这不是我们希望看到的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919174448465.png&#34; alt=&#34;image-20200919174448465&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Side&lt;/span&gt;{ Right, Left };
&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Thing&lt;/span&gt;{ Wrong, Right }; &lt;span style=&#34;color:#75715e&#34;&gt;// error: redefinition of enumerator &amp;#39;Right&amp;#39;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++11 引入了枚举类（enumaration class），并使用 &lt;code&gt;enum class&lt;/code&gt; 的语法进行声明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;new_enum&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; {
    value1,
    value2,
    value3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;,
    value4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那么可以进行比较：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (new_enum&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;value3 &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; new_enum&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;value4) {
    &lt;span style=&#34;color:#75715e&#34;&gt;// 会输出
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;new_enum::value3 == new_enum::value4&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919181720830.png&#34; alt=&#34;image-20200919181720830&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;lambda-c11&#34;&gt;lambda (C++11)&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;

&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; lam &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [](&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;m;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lam(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);
    cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; res &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到拿到外部数据值的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值捕获：与参数传值类似，值捕获的前期是变量可以拷贝，不同之处则在于，被捕获的变量在 lambda 表达式被创建时拷贝，而非调用时才拷贝；lambda表达式创建后改变变量，lambda中不会发生变化&lt;/li&gt;
&lt;li&gt;引用捕获：与引用传参类似，引用捕获保存的是引用，值会发生变化。&lt;/li&gt;
&lt;li&gt;隐式捕获：手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个 &lt;code&gt;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;=&lt;/code&gt; 向编译器声明采用 引用捕获或者值捕获.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919183447898.png&#34; alt=&#34;image-20200919183447898&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛型 Lambda：&lt;code&gt;auto&lt;/code&gt; 关键字不能够用在参数表里，这是因为这样的写法会与模板的功能产生冲突。但是 Lambda 表达式并不是普通函数，所以 Lambda 表达式并不能够模板化。这就为我们造成了一定程度上的麻烦：参数表不能够泛化，必须明确参数表类型；幸运的是，从 C++14 开始，Lambda 函数的形式参数可以使用 &lt;code&gt;auto&lt;/code&gt; 关键字来产生意义上的泛型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919183724921.png&#34; alt=&#34;image-20200919183724921&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;右值引用-c11&#34;&gt;右值引用 (C++11)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;左值(lvalue, left value)&lt;/strong&gt;，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋值表达式）后依然存在的持久对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右值(rvalue, right value)&lt;/strong&gt;，右边的值，是指表达式结束后就不再存在的临时对象。&lt;/p&gt;
&lt;p&gt;而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯右值(prvalue, pure rvalue)&lt;/strong&gt;，纯粹的右值，要么是纯粹的字面量，例如 &lt;code&gt;10&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt;；要么是求值结果相当于字面量或匿名临时对象，例如 &lt;code&gt;1+2&lt;/code&gt;。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将亡值(xvalue, expiring value)&lt;/strong&gt;，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++中，纯右值和右值是统一个概念），也就是即将被销毁、却能够被移动的值。&lt;/p&gt;
&lt;p&gt;将亡值可能稍有些难以理解，我们来看这样的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; foo() {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;};
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; temp;
}


std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; foo();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这样的代码中，函数 &lt;code&gt;foo&lt;/code&gt; 的返回值 &lt;code&gt;temp&lt;/code&gt; 在内部创建然后被赋值给 &lt;code&gt;v&lt;/code&gt;，然而 &lt;code&gt;v&lt;/code&gt; 获得这个对象时，会将整个 temp 拷贝一份，然后把 &lt;code&gt;temp&lt;/code&gt; 销毁，如果这个 &lt;code&gt;temp&lt;/code&gt; 非常大，这将造成大量额外的开销（这也就是传统 C++ 一直被诟病的问题）。在最后一行中，&lt;code&gt;v&lt;/code&gt; 是左值、&lt;code&gt;foo()&lt;/code&gt; 返回的值就是右值（也是纯右值）。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;v&lt;/code&gt; 可以被别的变量捕获到，而 &lt;code&gt;foo()&lt;/code&gt; 产生的那个返回值作为一个临时值，一旦被 &lt;code&gt;v&lt;/code&gt; 复制后，将立即被销毁，无法获取、也不能修改。&lt;/p&gt;
&lt;p&gt;将亡值就定义了这样一种行为：临时的值能够被识别、同时又能够被移动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右值引用和左值引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要拿到一个将亡值，就需要用到右值引用的申明：&lt;code&gt;T &amp;amp;&amp;amp;&lt;/code&gt;，其中 &lt;code&gt;T&lt;/code&gt; 是类型。右值引用的声明让这个临时值的生命周期得以延长、只要变量还活着，那么将亡值将继续存活。&lt;/p&gt;
&lt;p&gt;C++11 提供了 &lt;code&gt;std::move&lt;/code&gt; 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;移动语义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。试想，搬家的时候是把家里的东西直接搬到新家去，而不是将所有东西复制一份（重买）再放到新家、再把原来的东西全部扔掉（销毁），这是非常反人类的一件事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919223530282.png&#34; alt=&#34;image-20200919223530282&#34;&gt;&lt;/p&gt;
&lt;p&gt;在上面的代码中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先会在 &lt;code&gt;return_rvalue&lt;/code&gt; 内部构造两个 &lt;code&gt;A&lt;/code&gt; 对象，于是获得两个构造函数的输出；&lt;/li&gt;
&lt;li&gt;函数返回后，产生一个将亡值，被 &lt;code&gt;A&lt;/code&gt; 的移动构造（&lt;code&gt;A(A&amp;amp;&amp;amp;)&lt;/code&gt;）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 &lt;code&gt;obj&lt;/code&gt; 中，而将亡值的指针被设置为 &lt;code&gt;nullptr&lt;/code&gt;，防止了这块内存区域被销毁。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从而避免了无意义的拷贝构造，加强了性能&lt;/p&gt;
&lt;p&gt;下面这个例子直观一点：&lt;/p&gt;
&lt;p&gt;当有移动构造函数时将亡值会以移动的方式从被调用函数返回结果传回给main；没有移动构造函数时只能复制一遍（消耗较大）&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920094036279.png&#34; alt=&#34;image-20200920094036279&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920094052465.png&#34; alt=&#34;image-20200920094052465&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C++&#34; data-lang=&#34;C++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt; // std::cout&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;utility&amp;gt;  // std::move&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;vector&amp;gt;   // std::vector&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;string&amp;gt;   // std::string&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Hello world.&amp;#34;&lt;/span&gt;;
    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; v;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 将使用 push_back(const T&amp;amp;), 即产生拷贝行为
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    v.push_back(str);
    &lt;span style=&#34;color:#75715e&#34;&gt;// 将输出 &amp;#34;str: Hello world.&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;str: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; str &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 将使用 push_back(const T&amp;amp;&amp;amp;), 不会出现拷贝行为
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 而整个字符串会被移动到 vector 中，所以有时候 std::move 会用来减少拷贝出现的开销
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 这步操作后, str 中的值会变为空
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    v.push_back(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;move(str));
    &lt;span style=&#34;color:#75715e&#34;&gt;// 将输出 &amp;#34;str: &amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;str: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; str &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;endl;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;要调用参数为右值的移动函数，就必须传右值进去；此时传右值仅仅表示要去找参数为右值的对应函数，具体怎么通过移动减少拷贝开销要看这个函数怎么实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201108200529546.png&#34; alt=&#34;image-20201108200529546&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完美转发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面我们提到了，一个声明的右值引用其实是一个左值。这就为我们进行参数转发（传递）造成了问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919211536459.png&#34; alt=&#34;image-20200919211536459&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;pass(1)&lt;/code&gt; 来说，虽然传递的是右值，但由于 &lt;code&gt;v&lt;/code&gt; 是一个引用，所以同时也是左值。因此 &lt;code&gt;reference(v)&lt;/code&gt; 会调用 &lt;code&gt;reference(int&amp;amp;)&lt;/code&gt;，输出『左值』。而对于&lt;code&gt;pass(v)&lt;/code&gt;而言，&lt;code&gt;v&lt;/code&gt;是一个左值，为什么会成功传递给 &lt;code&gt;pass(T&amp;amp;&amp;amp;)&lt;/code&gt; 呢？&lt;/p&gt;
&lt;p&gt;这是基于&lt;strong&gt;引用坍缩规则&lt;/strong&gt;的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引用，又能右引用。但是却遵循如下规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919211550732.png&#34; alt=&#34;image-20200919211550732&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，模板函数中使用 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; 不一定能进行右值引用，当传入左值时，此函数的引用将被推导为左值。更准确的讲，&lt;strong&gt;无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为右引用类型&lt;/strong&gt;。这才使得 &lt;code&gt;v&lt;/code&gt; 作为左值的成功传递。&lt;/p&gt;
&lt;p&gt;完美转发就是基于上述规律产生的。所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 &lt;code&gt;std::forward&lt;/code&gt; 来进行参数的转发（传递）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200919211456940.png&#34; alt=&#34;image-20200919211456940&#34;&gt;&lt;/p&gt;
&lt;p&gt;普通传参一定传左值，move一定转换为右值，forward保持原来性质&lt;/p&gt;
&lt;h4 id=&#34;unordered_map--unordered_set-c11&#34;&gt;unordered_map &amp;amp; unordered_set (C++11)&lt;/h4&gt;
&lt;p&gt;我们已经熟知了传统 C++ 中的有序容器 &lt;code&gt;std::map&lt;/code&gt;/&lt;code&gt;std::set&lt;/code&gt;，这些元素内部通过红黑树进行实现，插入和搜索的平均复杂度均为 &lt;code&gt;O(log(size))&lt;/code&gt;。在插入元素时候，会根据 &lt;code&gt;&amp;lt;&lt;/code&gt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt;code&gt;&amp;lt;&lt;/code&gt; 操作符的顺序来逐个遍历。&lt;/p&gt;
&lt;p&gt;而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 &lt;code&gt;O(constant)&lt;/code&gt;，在不关心容器内部元素顺序时，能够获得显著的性能提升。&lt;/p&gt;
&lt;h4 id=&#34;noexcept-的修饰和操作-c11&#34;&gt;noexcept 的修饰和操作 (C++11)&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;noexcept&lt;/code&gt; 修饰过的函数如果抛出异常，编译器会使用 &lt;code&gt;std::terminate()&lt;/code&gt; 来立即终止程序运行。&lt;/p&gt;
&lt;h4 id=&#34;智能指针-c11&#34;&gt;智能指针 (C++11)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;shared_ptr&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用引用计数-&amp;gt;每有一个指针指向相同的一片内存时，引用计数+1，每当一个指针取消指向一片内存时，引用计数-1，减为0时释放内存。&lt;/p&gt;
&lt;p&gt;但还不够，因为使用 &lt;code&gt;std::shared_ptr&lt;/code&gt; 仍然需要使用 &lt;code&gt;new&lt;/code&gt; 来调用，这使得代码出现了某种程度上的不对称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::make_shared&lt;/code&gt; 就能够用来消除显示的使用 &lt;code&gt;new&lt;/code&gt;，所以&lt;code&gt;std::make_shared&lt;/code&gt; 会分配创建传入参数中的对象，并返回这个对象类型的&lt;code&gt;std::shared_ptr&lt;/code&gt;指针。&amp;lt;&amp;gt;中填入类名，()中填入初始化用的参数，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920003545194.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::shared_ptr&lt;/code&gt; 可以通过 &lt;code&gt;get()&lt;/code&gt; 方法来获取原始指针，通过 &lt;code&gt;reset()&lt;/code&gt; 来减少一个引用计数，并通过&lt;code&gt;get_count()&lt;/code&gt;来查看一个对象的引用计数，&lt;code&gt;unique()&lt;/code&gt;: 判断是否是唯一指向当前内存的shared_ptr.。例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920005708179.png&#34; alt=&#34;image-20200920005708179&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;unique_ptr&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（禁止拷贝、赋值），可以释放所有权，转移所有权。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pointer &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;make_unique&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);   &lt;span style=&#34;color:#75715e&#34;&gt;// make_unique 从 C++14 引入
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; pointer2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pointer;    &lt;span style=&#34;color:#75715e&#34;&gt;// 非法
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920004258513.png&#34; alt=&#34;image-20200920004258513&#34;&gt;&lt;/p&gt;
&lt;p&gt;既然是独占，换句话说就是不可复制。但是，我们可以利用 &lt;code&gt;std::move&lt;/code&gt; 将其转移给其他的 &lt;code&gt;unique_ptr&lt;/code&gt;（或者用unique_ptr的swap方法也可以），例如&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920005310162.png&#34; alt=&#34;image-20200920005310162&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;weak_ptr&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果你仔细思考 &lt;code&gt;std::shared_ptr&lt;/code&gt; 就会发现依然存在着资源无法释放的问题。看下面这个例子（循环引用）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031143530136.png&#34; alt=&#34;image-20201031143530136&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920004850088.png&#34; alt=&#34;image-20200920004850088&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920004905179.png&#34; alt=&#34;image-20200920004905179&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031143503235.png&#34; alt=&#34;image-20201031143503235&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;std::weak_ptr&lt;/code&gt; 没有 &lt;code&gt;*&lt;/code&gt; 运算符和 &lt;code&gt;-&amp;gt;&lt;/code&gt; 运算符，所以不能够对资源进行操作，它的唯一作用就是用于检查 &lt;code&gt;std::shared_ptr&lt;/code&gt; 是否存在，&lt;code&gt;expired()&lt;/code&gt; 方法在资源未被释放时，会返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt;；&lt;code&gt;lock()&lt;/code&gt;方法用来获取weak_ptr指向对象的shared_ptr&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>Operating System</title>
      <link>https://president810.github.io/Cpp-Interview-Notes/interview/operatingsystem/</link>
      <pubDate>Thu, 24 Dec 2020 23:41:42 +0800</pubDate>
      
      <guid>https://president810.github.io/Cpp-Interview-Notes/interview/operatingsystem/</guid>
      <description>
        
          &lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;
&lt;h3 id=&#34;linux&#34;&gt;Linux&lt;/h3&gt;
&lt;h4 id=&#34;用户态到内核态的切换&#34;&gt;用户态到内核态的切换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这是用户态进程主动要求切换到内核态的一种方式&lt;/strong&gt;，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前例中fork()实际上就是执行了一个创建新进程的系统调用。&lt;/p&gt;
&lt;p&gt;用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外围设备的中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号&lt;/strong&gt;，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，&lt;/p&gt;
&lt;p&gt;如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。&lt;/p&gt;
&lt;h4 id=&#34;用户态和内核态区别&#34;&gt;用户态和内核态区别&lt;/h4&gt;
&lt;p&gt;两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。&lt;/p&gt;
&lt;h4 id=&#34;为什么要分用户态和内核态&#34;&gt;为什么要分用户态和内核态&lt;/h4&gt;
&lt;p&gt;为了安全性。在cpu的一些指令中，有的指令如果用错，将会导致整个系统崩溃。 分了内核态和用户态后，当用户需要操作这些指令时候，内核为其提供了API，可 以通过系统调用陷入内核，让内核去执行这些操作。&lt;/p&gt;
&lt;h4 id=&#34;系统调用&#34;&gt;系统调用&lt;/h4&gt;
&lt;p&gt;系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务，如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。&lt;/p&gt;
&lt;h4 id=&#34;系统调用与普通函数库调用区别&#34;&gt;系统调用与普通函数库调用区别&lt;/h4&gt;
&lt;p&gt;函数库的API是相同的，系统调用的API取决于操作系统&lt;/p&gt;
&lt;p&gt;函数库调用的是函数库里面的一段程序，系统调用调用的是内核的服务&lt;/p&gt;
&lt;p&gt;函数库调用在用户态，系统调用在内核态&lt;/p&gt;
&lt;p&gt;函数库调用不用上下文切换，系统调用需要切换到内核态&lt;/p&gt;
&lt;h3 id=&#34;进程--线程&#34;&gt;进程 &amp;amp; 线程&lt;/h3&gt;
&lt;h4 id=&#34;父子进程&#34;&gt;父子进程&lt;/h4&gt;
&lt;p&gt;创建进程：pid_t fork(void)&lt;/p&gt;
&lt;p&gt;返回值：创建失败返回-1，创建成功返回0给创建的子进程，返回子进程号给父进程&lt;/p&gt;
&lt;p&gt;子进程将父进程地址空间拷贝一份（出于内存管理原因可能一开始不会拷贝成两份），父子进程从fork的下一行开始执行&lt;/p&gt;
&lt;p&gt;结束进程：exit()&lt;/p&gt;
&lt;p&gt;等待子进程：pit_t wait(int *status_ptr) / pid_t waitpid(pid_t pid, int *status_ptr, int options)，等待直到子进程状态码可用，然后将子进程状态码拷贝到 *status_ptr&lt;/p&gt;
&lt;p&gt;返回值：不成功时返回-1，子进程状态码可用时返回子进程号&lt;/p&gt;
&lt;p&gt;执行程序：execve(const char *filename, const char *arg0, char *const env[]&amp;hellip;)&lt;/p&gt;
&lt;p&gt;不会再创建新进程，pid不变，机器码，数据，堆，栈替换为新程序的数据&lt;/p&gt;
&lt;p&gt;返回值：不成功返回-1，成功不返回值（代码已被替换）&lt;/p&gt;
&lt;h4 id=&#34;僵尸进程孤儿进程&#34;&gt;僵尸进程，孤儿进程&lt;/h4&gt;
&lt;p&gt;僵尸进程：子进程退出但父进程没有wait获取其状态信息，子进程进程描述符仍保存在系统中；会占用进程号最终导致系统没有可用的进程号而不能产生新的进程；kill掉父进程后变为孤儿进程以解决问题&lt;/p&gt;
&lt;p&gt;孤儿进程：父进程退出但子进程还在运行，孤儿进程会被init进程收养；init进程会wait孤儿进程故危害不大&lt;/p&gt;
&lt;h4 id=&#34;守护进程&#34;&gt;守护进程&lt;/h4&gt;
&lt;p&gt;守护进程：Linux Daemon（守护进程）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。Linux系统的大多数服务器就是通过守护进程实现的。常见的守护进程包括系统日志进程syslogd、 web服务器httpd、邮件服务器sendmail和数据库服务器mysqld等。&lt;/p&gt;
&lt;p&gt;守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程经常以超级用户（root）权限运行，因为它们要使用特殊的端口（1-1024）或访问某些特殊的资源。&lt;/p&gt;
&lt;p&gt;一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程&lt;/p&gt;
&lt;h4 id=&#34;进程线程区别&#34;&gt;进程线程区别&lt;/h4&gt;
&lt;p&gt;调度：线程作为调度和分配的基本单位，进程作为资源分配的独立单元&lt;/p&gt;
&lt;p&gt;并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行&lt;/p&gt;
&lt;p&gt;拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.&lt;/p&gt;
&lt;p&gt;系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。&lt;/p&gt;
&lt;p&gt;切换：进程切换与线程切换的一个最主要区别就在于进程切换涉及到虚拟地址空间的切换而线程切换则不会（所以进程切换慢）&lt;/p&gt;
&lt;h4 id=&#34;上下文切换&#34;&gt;上下文切换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;系统调用（内核态用户态切换）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从用户态到内核态的转变，需要通过&lt;strong&gt;系统调用&lt;/strong&gt;来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。&lt;/p&gt;
&lt;p&gt;在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：
1、保存 CPU 寄存器里原来用户态的指令位
2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。
3、跳转到内核态运行内核任务。
4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;一次系统调用的过程，其实是发生了两次 CPU 上下文切换&lt;/strong&gt;。（用户态-内核态-用户态）&lt;/p&gt;
&lt;p&gt;不过，需要注意的是，&lt;strong&gt;系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程&lt;/strong&gt;。这跟我们通常所说的进程上下文切换是不一样的：&lt;strong&gt;进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，&lt;strong&gt;进程是由内核来管理和调度的，进程的切换只能发生在内核态&lt;/strong&gt;。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。&lt;/p&gt;
&lt;p&gt;因此，&lt;strong&gt;进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同一个进程的线程间切换时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据&lt;/p&gt;
&lt;h4 id=&#34;为什么进程切换慢&#34;&gt;为什么进程切换慢&lt;/h4&gt;
&lt;p&gt;每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么当进程切换后页表也要进行切换，页表切换后会导致TLB失效（TLB就是当前页表的缓存），cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换比进程切换快，原因就在这里。&lt;/p&gt;
&lt;h4 id=&#34;ipc&#34;&gt;IPC&lt;/h4&gt;
&lt;p&gt;管道：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程（父子进程）之间使用，缓冲区有限&lt;/p&gt;
&lt;p&gt;有名管道（FIFO）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式，缓冲区有限&lt;/p&gt;
&lt;p&gt;（管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了）&lt;/p&gt;
&lt;p&gt;消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。&lt;/p&gt;
&lt;p&gt;信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。&lt;/p&gt;
&lt;p&gt;信号：用于通知接收进程某个事件已经发生。信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的&lt;/p&gt;
&lt;p&gt;共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问；效率最高，但没有提供同步机制，需要使用锁等其他机制进行同步。&lt;/p&gt;
&lt;p&gt;套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。&lt;/p&gt;
&lt;h4 id=&#34;同一个进程内的线程会共享什么资源&#34;&gt;同一个进程内的线程会共享什么资源？&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;该进程的地址空间&lt;/li&gt;
&lt;li&gt;全局变量&lt;/li&gt;
&lt;li&gt;堆空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程调度算法&#34;&gt;进程调度算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;先来先服务（FCFS）：简单但效率低，适合CPU密集任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点是公平，实现简单；缺点是不利于短作业&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间片轮转调度法（RR）：时间片短则开销大，时间片长则退化为先来先服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最短作业优先（SJF）：平均等待时间最少，但作业时间长短只能靠由历史长度预测（指数平均）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最短剩余时间（SRF）：最短进程优先的抢占机制版本，选择预期剩余时间最短的进程（即使是新加入的进程）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先级调度算法（Priority）：抢占/非抢占，导致饥饿（低优先级一直不被执行），通过衰老（随时间增大优先级）解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级队列算法（Multilevel）：队列内调度（RR/FCFS） / 队列间调度（固定优先级/时间片）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么时候用多线程什么时候用多进程&#34;&gt;什么时候用多线程什么时候用多进程？&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;对比维度&lt;/th&gt;
&lt;th&gt;多进程&lt;/th&gt;
&lt;th&gt;多线程&lt;/th&gt;
&lt;th&gt;优势&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数据共享、同步&lt;/td&gt;
&lt;td&gt;数据共享复杂，需要用IPC；数据是分开的，同步简单&lt;/td&gt;
&lt;td&gt;因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂&lt;/td&gt;
&lt;td&gt;各有优势&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存、CPU&lt;/td&gt;
&lt;td&gt;占用内存多，切换复杂，CPU利用率低&lt;/td&gt;
&lt;td&gt;占用内存少，切换简单，CPU利用率高&lt;/td&gt;
&lt;td&gt;线程占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;创建销毁切换&lt;/td&gt;
&lt;td&gt;创建销毁切换复杂，速度慢&lt;/td&gt;
&lt;td&gt;创建销毁切换简单，速度很快&lt;/td&gt;
&lt;td&gt;线程占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可靠性&lt;/td&gt;
&lt;td&gt;进程间不会互相影响&lt;/td&gt;
&lt;td&gt;一个线程挂掉将导致整个进程挂掉&lt;/td&gt;
&lt;td&gt;进程占优&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分布式&lt;/td&gt;
&lt;td&gt;适应于多核、多机分布式如果一台机器不够，扩展到多台机器比较简单&lt;/td&gt;
&lt;td&gt;适应于多核分布式&lt;/td&gt;
&lt;td&gt;进程占优&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;同步异步阻塞非阻塞&#34;&gt;同步异步，阻塞非阻塞&lt;/h4&gt;
&lt;p&gt;同步按一定响应时间进行IO；异步响应时间无规则或不可预测&lt;/p&gt;
&lt;p&gt;阻塞在IO执行时挂起进程（waiting）；非阻塞不挂起进程而是立即返回，IO执行多少返回多少&lt;/p&gt;
&lt;h4 id=&#34;io复用&#34;&gt;IO复用&lt;/h4&gt;
&lt;p&gt;I/O多路复用，I/O就是指的我们网络I/O，多路指多个TCP连接(或多个Channel)，复用指复用一个或少量进程。串起来理解就是很多个网络I/O复用一个或少量的进程来处理这些连接，让单个进程具有处理多个 I/O 事件的能力&lt;/p&gt;
&lt;h4 id=&#34;epoll的et模式和lt模式&#34;&gt;Epoll的ET模式和LT模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。&lt;/li&gt;
&lt;li&gt;LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;并行并发&#34;&gt;并行&amp;amp;并发&lt;/h4&gt;
&lt;p&gt;并行：支持同时执行多于一个任务；并发：支持多于一个任务一起取得进展（不一定同时运行）&lt;/p&gt;
&lt;h4 id=&#34;pthread&#34;&gt;pthread&lt;/h4&gt;
&lt;p&gt;创建线程：int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(start_routine)(void *), voidd *arg)&lt;/p&gt;
&lt;p&gt;thread：新创建的线程ID指向的内存单元，start_routine是线程开始执行的函数地址，arg是这个函数的参数&lt;/p&gt;
&lt;p&gt;返回值：错误返回错误码，成功返回0&lt;/p&gt;
&lt;p&gt;退出线程：void pthread_exit(void *retval)&lt;/p&gt;
&lt;p&gt;main() 执行完时如果线程没执行完会继续执行&lt;/p&gt;
&lt;p&gt;阻塞线程：int pthread_join(pthread_t thread, void **retval)&lt;/p&gt;
&lt;p&gt;阻塞调用线程，直到指定的线程（参数thread）终止&lt;/p&gt;
&lt;p&gt;互斥锁：pthread_mutex_t&lt;/p&gt;
&lt;p&gt;上锁：&lt;/p&gt;
&lt;p&gt;int pthread_mutex_lock(pthread_mutex *mutex)&lt;/p&gt;
&lt;p&gt;上锁，如果已经被锁则阻塞线程&lt;/p&gt;
&lt;p&gt;int pthread_mutex_trylock(pthread_mutex *mutex)&lt;/p&gt;
&lt;p&gt;试图上锁，如果已经上锁则返回错误码&lt;/p&gt;
&lt;p&gt;int pthread_mutex_unlock(pthread_mutex *mutex)&lt;/p&gt;
&lt;p&gt;解锁，只能解锁自己上的锁；已经被解锁或被其它线程上锁时返回错误码&lt;/p&gt;
&lt;p&gt;条件变量：pthread_cond_t&lt;/p&gt;
&lt;p&gt;int pthread_cond_wait(pthread_cont_t *t, pthread_mutex_t *mutex)&lt;/p&gt;
&lt;p&gt;阻塞调用线程直到条件变量被发信号&lt;/p&gt;
&lt;p&gt;int pthread_cond_signal(pthread_cond_t *t)&lt;/p&gt;
&lt;p&gt;给条件变量发信号从而唤醒另一个等待中的线程&lt;/p&gt;
&lt;p&gt;int pthread_cond_broadcast(pthread_cond_t *t)&lt;/p&gt;
&lt;p&gt;当多于一个线程在等待条件变量时使用&lt;/p&gt;
&lt;h4 id=&#34;协程&#34;&gt;协程&lt;/h4&gt;
&lt;p&gt;协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。&lt;/li&gt;
&lt;li&gt;线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。&lt;/li&gt;
&lt;li&gt;由于在同一个线程上，因此可以避免竞争关系而使用锁。&lt;/li&gt;
&lt;li&gt;适用于被阻塞的，且需要大量并发的场景。但不适用于大量计算的多线程，遇到此种情况，更好实用线程去解决。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中断&#34;&gt;中断&lt;/h3&gt;
&lt;h4 id=&#34;中断是什么&#34;&gt;中断是什么&lt;/h4&gt;
&lt;p&gt;早期的CPU处理外设的事件(比如接收键盘输入)，往往采用“轮询”的方式。即CPU像个查岗的一样轮番对外设顺序访问，比如它先看看键盘有没被按下，有的话就处理，没的话继续往下看鼠标有没有移动，再看看打印机……这种方式使CPU的执行效率很低，且CPU与外设不能同时工作（因为要等待CPU来“巡查”）。&lt;/p&gt;
&lt;p&gt;中断模式时就是说CPU不主动访问这些设备，只管处理自己的任务。如果有设备要与CPU联系，或要CPU处理一些事情，它会给CPU发一个中断请求信号。这时CPU就会放下正在进行的工作而去处理这个外设的请求。处理完中断后，CPU返回去继续执行中断以前的工作。&lt;/p&gt;
&lt;h4 id=&#34;中断类型&#34;&gt;中断类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;硬件中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬件中断又称外部中断，主要分为两种：可屏蔽中断、非屏蔽中断。&lt;/p&gt;
&lt;p&gt;可屏蔽中断：&lt;/p&gt;
&lt;p&gt;常由计算机的外设或一些接口功能产生，如键盘、打印机、串行口等；这种类型的中断可以在CPU要处理其它紧急操作时，被软件屏蔽或忽略&lt;/p&gt;
&lt;p&gt;典型的可屏蔽中断的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机稍等待一会也是完全合理的。&lt;/p&gt;
&lt;p&gt;非屏蔽中断：&lt;/p&gt;
&lt;p&gt;由意外事件导致，如电源断电、内存校验错误等；对于这种类型的中断事件，无法通过软件进行屏蔽，CPU必须无条件响应&lt;/p&gt;
&lt;p&gt;典型的非屏蔽中断的例子是电源断电，一旦出现此中断请求，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;软件中断&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软件中断又称内部中断，是指在程序中调用INTR中断指令引起的中断&lt;/p&gt;
&lt;h4 id=&#34;中断过程&#34;&gt;中断过程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;中断请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中断请求是由中断源向CPU发出中断请求信号。外部设备发出中断请求信号要具备以下两个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;外部设备的工作已经告一段落。例如输入设备只有在启动后，将要输入的数据送到接口电路的数据寄存器（即准备好要输入的数据）之后，才可以向CPU发出中断请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统允许该外设发出中断请求。如果系统不允许该外设发出中断请求，可以将这个外设的请求屏蔽。当这个外设中断请求被屏蔽，虽然这个外设准备工作已经完成，也不能发出中断请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;中断响应、处理和返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当满足了中断的条件后，CPU就会响应中断，转入中断程序处理。具体的工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;关闭中断信号接收器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保存现场(context)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;给出中断入口，转入相应的中断服务程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理完成，返回并恢复现场(context)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启中断信号接收器&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;中断排队和中断判优&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;中断申请是随机的，有时会出现多个中断源同时提出中断申请。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU每次只能响应一个中断源的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CPU不可能对所有中断请求一视同仁，它会根据各中断源工作性质的轻重缓急，预先安排一个优先级顺序。当多个中断源同时申请中断时，即按此优先级顺序进行排队，等候CPU处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;为什么在中断过程中不能进行睡眠&#34;&gt;为什么在中断过程中不能进行睡眠&lt;/h4&gt;
&lt;p&gt;运行在中断中的代码不能进行睡眠，或者阻塞！因为代码是运行在中断上下文中，并非进程上下文中，如果将中断进行睡眠的话，调度器无从得知下一个应该调度的进程，系统无法继续进行！&lt;/p&gt;
&lt;h3 id=&#34;锁&#34;&gt;锁&lt;/h3&gt;
&lt;h4 id=&#34;死锁原因&#34;&gt;死锁原因&lt;/h4&gt;
&lt;p&gt;（1） 互斥条件：一个资源每次只能被一个进程使用。&lt;/p&gt;
&lt;p&gt;（2） 请求保持条件：一个进程因请求资源而阻塞时，保持不放已获得的资源。&lt;/p&gt;
&lt;p&gt;（3） 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。&lt;/p&gt;
&lt;p&gt;（4） 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。&lt;/p&gt;
&lt;h4 id=&#34;死锁预防&#34;&gt;死锁预防&lt;/h4&gt;
&lt;p&gt;破坏互斥条件：取决于资源本身&lt;/p&gt;
&lt;p&gt;破坏请求条件：申请一个资源时&lt;!-- raw HTML omitted --&gt;不能占有其它资源&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;破坏不可剥夺条件：申请一个不能立即分配的资源时&lt;!-- raw HTML omitted --&gt;已占有的资源都可抢占&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;破坏环路等待条件：资源有序分配，系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反&lt;/p&gt;
&lt;h4 id=&#34;死锁避免银行家算法&#34;&gt;死锁避免（银行家算法）&lt;/h4&gt;
&lt;p&gt;m：资源数量；n：进程数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Available&lt;/strong&gt;：这是一个含有m个元素的数组，其中的而每一个元素代表一类可利用资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态的改变。如果Available[j]=K,则表示系统中现有Rj类资源K个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Max&lt;/strong&gt;：这是一个n*m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j]=K；则表示进程i需要Rj类资源的最大数目为K。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Allocation&lt;/strong&gt;：这也是一个n*m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Need&lt;/strong&gt;：这也是一个n*m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j]=K,则表示进程i还需要Rj类资源K个，方能完成任务。&lt;/p&gt;
&lt;p&gt;上述三个矩阵间存在下述关系：Need[i,j]=Max[i,j]-Allocation[i,j]&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安全性算法：检测目前计算机的资源是不是足够这些进程完成任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Work&lt;/strong&gt;：长度为m的向量，初始等于Allocation，表示当前能提供的资源数量；当一个进程目前分配的资源有能力完成任务时，会将已经分配给此进程的资源Allocation_i加到work上（进程完成任务，不需要继续持有资源）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Finish&lt;/strong&gt;：长度为n的向量，初始全为false，表示进程有没有完成任务；当进程有足够资源完成任务时变为true&lt;/p&gt;
&lt;p&gt;进程如果有能力完成任务（Need_i&amp;lt;Work_i），则Finish_i变为true，并且Work=Work+Allocation_i&lt;/p&gt;
&lt;p&gt;当没有有能力完成任务且未完成的进程时，检查是不是所有进程都完成了任务，如果是则系统处于安全状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;资源请求算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Request_i&lt;/strong&gt;：进程i请求的资源数量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查Request_i小于等于Need_i，否则出错（请求的太多了）&lt;/li&gt;
&lt;li&gt;检查Request_i小于等于Available，否则必须等待（现在给不了你这么多，但是后面可能可以）&lt;/li&gt;
&lt;li&gt;将Allocation的资源按Request_i的量分给进程i，如果产生的新状态是安全的，则进程i可以拿到其所需要资源，否则必须等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;安全性算法保证系统一定能找到一种调度方式保证死锁不产生；资源请求算法保证进程请求资源不会让系统进入不安全状态&lt;/p&gt;
&lt;h4 id=&#34;解决死锁&#34;&gt;解决死锁&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;阻塞住占据资源的一个进程并剥夺它占有的资源，让它把资源先分给需要这个资源的进程&lt;/li&gt;
&lt;li&gt;直接kill一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有互斥锁为什么还要条件变量&#34;&gt;有互斥锁为什么还要条件变量？&lt;/h4&gt;
&lt;p&gt;条件变量是某个条件被满足时会发出信号告诉别的线程；互斥锁是保证同一时间只有一个线程拥有资源&lt;/p&gt;
&lt;p&gt;假如我们没有“条件变量”这个概念，如果一个线程要等待某个“自定义的条件”满足而继续执行，而这个条件只能由另一个线程来满足，比如 T1不断给一个全局变量 x +1， T2检测到x 大于100时，将x 置0，如果我们没有条件变量只通过互斥锁实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//thread 1:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(true){
    pthread_mutex_lock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    iCount&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    pthread_mutex_unlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
}

&lt;span style=&#34;color:#75715e&#34;&gt;//thread 2:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(true){
    pthread_mutex_lock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(iCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;){
        iCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
    pthread_mutex_unlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时就算 lock 空闲，thread2也需要不断重复&amp;lt;加锁，判断，解锁&amp;gt;这个流程，会给系统带来不必要的开销。有没有一种办法让 thread2先被 block，等条件满足的时候再唤醒 thread2？这样 thread2 就不用不断进行重复的加解锁操作了？这就要用到条件变量了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//thread1 :
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(true){
    pthread_mutex_lock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    iCount&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    pthread_mutex_unlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);

    pthread_mutex_lock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(iCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;){
        pthread_cond_signal(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cond);
    }
    pthread_mutex_unlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
}

&lt;span style=&#34;color:#75715e&#34;&gt;//thread2:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;){
    pthread_mutex_lock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(iCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;){
        pthread_cond_wait(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cond, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
    }
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;iCount &amp;gt;= 100&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\r\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    iCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    pthread_mutex_unlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mutex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;为什么条件变量里还要传入一个互斥锁&#34;&gt;为什么条件变量里还要传入一个互斥锁&lt;/h4&gt;
&lt;p&gt;还是上面那个例子，T2会在iCount小于100时等待条件变量唤醒，如何线程1里iCount大于100了，则T2被唤醒；但是如果此时T2没有在被唤醒的一瞬间锁住iCount这个变量的话，其它线程可以在很短的时间内再次将iCount变为小于100的值，这样T2就又会被锁住（没来得及跳出while循环），要想做到T2醒来这段时间iCount这个条件不再发生改变，就需要让条件变量和互斥锁绑定，条件变量进行唤醒的同时加互斥锁防止条件被再次改变，从而避免上面这种情况的发生&lt;/p&gt;
&lt;h4 id=&#34;自旋锁与互斥锁&#34;&gt;自旋锁与互斥锁&lt;/h4&gt;
&lt;p&gt;自旋锁无法拿到锁时不阻塞线程而是不停循环检测锁状态（耗CPU），线程不休眠所以不需条件变量，适合加锁时间短暂的情况下使用（耗费CPU资源不多，并且没有上下文切换损耗）&lt;/p&gt;
&lt;p&gt;互斥锁无法拿到锁时阻塞线程，线程进入休眠，一般与条件变量一起使用以发出信号唤醒线程适合加锁时间较长情况下使用&lt;/p&gt;
&lt;h4 id=&#34;独占锁与共享锁读写锁&#34;&gt;独占锁与共享锁（读写锁）&lt;/h4&gt;
&lt;p&gt;独占锁概念&lt;/p&gt;
&lt;p&gt;独占锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排他锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据&lt;/p&gt;
&lt;p&gt;共享锁概念&lt;/p&gt;
&lt;p&gt;共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。&lt;/p&gt;
&lt;h4 id=&#34;悲观锁与乐观锁&#34;&gt;悲观锁与乐观锁&lt;/h4&gt;
&lt;p&gt;乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。&lt;/p&gt;
&lt;p&gt;悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。&lt;/p&gt;
&lt;h4 id=&#34;cas机制&#34;&gt;CAS机制&lt;/h4&gt;
&lt;p&gt;CAS是英文单词Compare And Swap的缩写，翻译过来就是比较并替换。&lt;/p&gt;
&lt;p&gt;CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。&lt;/p&gt;
&lt;p&gt;更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B。如果不同，则回去重新执行整个操作（乐观锁）&lt;/p&gt;
&lt;h4 id=&#34;递归锁&#34;&gt;递归锁&lt;/h4&gt;
&lt;p&gt;例如bar函数和foo函数都获取了同一个锁，并且bar函数会调用foo函数，那么如果这个锁不是可递归锁时，程序会发生死锁&lt;/p&gt;
&lt;p&gt;可以通过设置pthread_mutex_recursive属性将互斥锁设置为可递归的&lt;/p&gt;
&lt;p&gt;在系统不支持递归锁，而又必须要使用时,就需要自己构造一个递归锁。通常，递&lt;strong&gt;归锁是在非递归互斥锁加引用计数器来实现的&lt;/strong&gt;。简单的说，在加锁前，先判断上一个加锁的线程和当前加锁的线程是否为同一个。如果是同一个线程，则仅仅引用计数器加1； 如果不是的话，则引用计数器设为1，则记录当前线程号，并加锁。&lt;/p&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理&lt;/h3&gt;
&lt;h4 id=&#34;堆栈区别&#34;&gt;堆栈区别&lt;/h4&gt;
&lt;p&gt;栈中分配局部变量、临时变量的内存空间，内存相对较少，所以开辟太多会导致栈溢出（例如使用递归的时候，递归层数太深或是没有递归终止的条件都可能导致栈溢出）；是一块连续的内存的区域；由系统自动分配，速度较快&lt;/p&gt;
&lt;p&gt;堆区是向上增长的用于分配程序员申请的内存空间，如malloc和new出来的空间都是放在堆区，手动申请释放，没能及时释放可能会导致内存泄漏的问题；是不连续的内存区域，用链表来存储的空闲内存地址；是程序员分配的内存，一般速度比较慢，分配的空间大于需要的空间时有内存碎片&lt;/p&gt;
&lt;h4 id=&#34;共享内存和虚拟内存&#34;&gt;共享内存和虚拟内存&lt;/h4&gt;
&lt;p&gt;共享内存：进程在运行过程中，会加载许多操作系统的动态库，比如 libc.so、libld.so等。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。如上图中的A4和B3部分即为共享内存，实际都映射到同一块物理内存。&lt;/p&gt;
&lt;p&gt;虚拟内存：由于成本的限制，物理内存往往无法做的很大，但是进程运行阶段所需申请的内存可能远远超过物理内存，并且系统不可能只跑一个进程，会有多个进程一起申请使用内存，如果都直接向物理内存进行申请使用肯定无法满足。通过引入虚拟内存，每个进程都有自己独立的虚拟地址空间，这个空间理论上可以无限大，因为它并不要钱。一个进程同一时刻不可能所有变量数据都会访问到，只需要在访问某部分数据时，把这一块虚拟内存映射到物理内存，其他没有实际访问过的虚拟地址空间并不会占用到物理内存，这样对物理内存的消耗就大大减少了&lt;/p&gt;
&lt;h4 id=&#34;换页算法&#34;&gt;换页算法&lt;/h4&gt;
&lt;p&gt;FIFO：置换时选择离调入时间最久的页&lt;/p&gt;
&lt;p&gt;LRU：置换时选择最长时间没有用到的页，计数器/栈实现&lt;/p&gt;
&lt;p&gt;近似LRU：二次机会，引用位0时置换，引用位1时变成0并重新选一个页；时钟算法，使用环形链表将页面连接起来，再使用一个指针指向最老的页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201030212646730.png&#34; alt=&#34;image-20201030212646730&#34;&gt;&lt;/p&gt;
&lt;p&gt;LFU / MFU：置换被引用次数最少 / 最多的页&lt;/p&gt;
&lt;h4 id=&#34;分段--分页&#34;&gt;分段 &amp;amp; 分页&lt;/h4&gt;
&lt;p&gt;分页：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;逻辑地址道物理地址变化原理：CPU中的内存管理单元(MMU)按逻辑页号通过查进程页表得到物理页框号，将物理页框号与页内地址相加形成物理地址。&lt;/li&gt;
&lt;li&gt;优点：没有外碎片，提高内存的利用率。一个程序不必连续存放。便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。&lt;/li&gt;
&lt;li&gt;缺点：无论数据有多少，都只能按照页面大小分配，容易产生内部碎片。无法体现程序逻辑。页长与程序的逻辑大小不相关。不利于编程时的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦。   分段存储&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地址映射: 在分段存储中，整个进程的地址空间是&lt;strong&gt;二维&lt;/strong&gt;的，即其逻辑地址由段号和段内地址两部分组成。&lt;/li&gt;
&lt;li&gt;优点：分段对程序员可见。段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。方便编程，分段共享，分段保护，动态链接，动态增长。&lt;/li&gt;
&lt;li&gt;缺点：主存空间分配比较麻烦。外部碎片。由于段长不一定是2的整数次幂，因而不能简单地像分页方式那样用虚拟地址和实存地址的最低若干二进制位作为段内地址，并与段号进行直接拼接，必须用加法操作通过段起址与段内地址的求和运算得到物理地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。&lt;/p&gt;
&lt;p&gt;地址空间的维度：分页是一维地址空间，分段是二维的。&lt;/p&gt;
&lt;p&gt;大小是否可以改变：页的大小不可变，段的大小可以动态改变。&lt;/p&gt;
&lt;p&gt;出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。&lt;/p&gt;
&lt;h4 id=&#34;段页式存储&#34;&gt;段页式存储&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201030211232454.png&#34; alt=&#34;image-20201030211232454&#34;&gt;&lt;/p&gt;
&lt;p&gt;为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块&lt;/p&gt;
&lt;p&gt;它首先将程序按其逻辑结构划分为若干个大小不等的逻辑段，然后再将每个逻辑段划分为若干个大小相等的逻辑页。主存空间也划分为若干个同样大小的物理页。辅存和主存之间的信息调度以页为基本传送单位，每个程序段对应一个段表，每页对应一个页表。&lt;/p&gt;
&lt;p&gt;段页式系统中，作业的地址结构包含三部分的内容：段号，页号，页内位移量&lt;/p&gt;
&lt;p&gt;CPU访问时，段表指示每段对应的页表地址，每一段的页表确定页所在的主存空间的位置，最后与页表内地址拼接，确定CPU要访问单元的物理地址。&lt;/p&gt;
&lt;p&gt;段页存储管理方式综合了段式管理和页式管理的优点，但需要经过两级查表才能完成地址转换，消耗时间多。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程：检查是否越界。利用段表始址和段号来求出该段所对应的段表项在段表中的位置，得到该段的页表始址。读出该页所在的物理块号b。构建物理地址。&lt;/li&gt;
&lt;li&gt;优点：提供了大量的虚拟存储空间。有效地利用主存，为组织多道程序运行提供了方便。&lt;/li&gt;
&lt;li&gt;缺点：增加了硬件成本、系统的复杂性和管理上的开销。存在系统抖动的风险。存在内碎片。各种表占用更多的空间。&lt;/li&gt;
&lt;/ul&gt;

        
      </description>
    </item>
    
    <item>
      <title>Data Structure</title>
      <link>https://president810.github.io/Cpp-Interview-Notes/interview/datastructure/</link>
      <pubDate>Thu, 24 Dec 2020 23:38:22 +0800</pubDate>
      
      <guid>https://president810.github.io/Cpp-Interview-Notes/interview/datastructure/</guid>
      <description>
        
          &lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;h3 id=&#34;哈希表&#34;&gt;哈希表&lt;/h3&gt;
&lt;p&gt;基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P=f(K),其中f成为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P=f(K).
当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址上，即K1!=K2，但f(K1)=f(K2),这种现象称为hash冲突&lt;/p&gt;
&lt;p&gt;开放定址法：
所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)
用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址为止（插入时探查到开放的地址则将待插入的新结点存人该地址单元；查找时探测到开放的地址则表明表中无待查的关键字即查找失败）&lt;/p&gt;
&lt;p&gt;链地址法：
链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来&lt;/p&gt;
&lt;h3 id=&#34;排序&#34;&gt;排序&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Algorithm&lt;/th&gt;
&lt;th&gt;Average time complexity&lt;/th&gt;
&lt;th&gt;Worst time complexity&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Space complexity&lt;/th&gt;
&lt;th&gt;Stable&lt;/th&gt;
&lt;th&gt;Place&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Bubble sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(1)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Selection sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(1)&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Insertion sort&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(1)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Shell sort&lt;/td&gt;
&lt;td&gt;O(n^1.16) (Sedgewick)&lt;/td&gt;
&lt;td&gt;O(n^1.33) (Sedgewick)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(1)&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Heap sort&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(1)&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Merge sort&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(n)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;Out-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Quick sort&lt;/td&gt;
&lt;td&gt;O(nlogn)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(logn)&lt;/td&gt;
&lt;td&gt;False&lt;/td&gt;
&lt;td&gt;In-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bucket sort&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n^2)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;Out-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Counting sort&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;O(n+k)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(k)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;Out-place&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Radix sort&lt;/td&gt;
&lt;td&gt;O(n*k)&lt;/td&gt;
&lt;td&gt;O(n*k)&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;O(n+k)&lt;/td&gt;
&lt;td&gt;True&lt;/td&gt;
&lt;td&gt;Out-place&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;(1)冒泡排序&lt;/p&gt;
&lt;p&gt;冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。&lt;/p&gt;
&lt;p&gt;(2)选择排序&lt;/p&gt;
&lt;p&gt;选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。&lt;/p&gt;
&lt;p&gt;(3)插入排序
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。&lt;/p&gt;
&lt;p&gt;(4)快速排序
快速排序有两个方向，左边的i下标一直往右走，当a[i] &amp;lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &amp;gt; a[center_index]。如果i和j都走不动了，i &amp;lt;= j，交换a[i]和a[j],重复上面的过程，直到i &amp;gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。&lt;/p&gt;
&lt;p&gt;(5)归并排序
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。&lt;/p&gt;
&lt;p&gt;(6)基数排序
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。&lt;/p&gt;
&lt;p&gt;(7)希尔排序(shell)
希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。&lt;/p&gt;
&lt;p&gt;(8)堆排序
我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， &amp;hellip; 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。&lt;/p&gt;
&lt;h3 id=&#34;最短路径&#34;&gt;最短路径&lt;/h3&gt;
&lt;h4 id=&#34;迪杰斯特拉&#34;&gt;迪杰斯特拉&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920234535266.png&#34; alt=&#34;image-20200920234535266&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;贝尔曼福特&#34;&gt;贝尔曼福特&lt;/h4&gt;
&lt;p&gt;对于一个图G(v,e)(v代表点集，e代表边集)，执行|v|-1次边集的松弛操作，所谓松弛操作，就是对于每个边e1(v,w)，将源点到w的距离更新为：原来源点到w的距离（如果还没有遍历过w则为源点到w距离为∞） 和 源点到v的距离加上v到w的距离 中较小的那个。v-1轮松弛操作之后，判断是否有源点能到达的负环，判断的方法就是，再执行一次边集的松弛操作，如果这一轮松弛操作，有松弛成功的边，那么就说明图中有负环。算法复杂度为O(VE)&lt;/p&gt;
&lt;h3 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h3&gt;
&lt;h4 id=&#34;prim&#34;&gt;Prim&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920235531586.png&#34; alt=&#34;image-20200920235531586&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;kruskal&#34;&gt;Kruskal&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200920235551309.png&#34; alt=&#34;image-20200920235551309&#34;&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>Database</title>
      <link>https://president810.github.io/Cpp-Interview-Notes/interview/database/</link>
      <pubDate>Thu, 24 Dec 2020 23:37:43 +0800</pubDate>
      
      <guid>https://president810.github.io/Cpp-Interview-Notes/interview/database/</guid>
      <description>
        
          &lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;
&lt;h3 id=&#34;关系型数据库&#34;&gt;关系型数据库&lt;/h3&gt;
&lt;h4 id=&#34;什么是关系型数据库&#34;&gt;什么是关系型数据库&lt;/h4&gt;
&lt;p&gt;关系型数据库是依据关系模型来创建的数据库，由表的集合组成，关系模型可以为一对一、一对多、多对多&lt;/p&gt;
&lt;h4 id=&#34;数据库范式&#34;&gt;数据库范式&lt;/h4&gt;
&lt;p&gt;1NF：每个属性都不可再分&lt;/p&gt;
&lt;p&gt;2NF：不存在非主属性对码的部分函数依赖（非主属性完全依赖于主关键字）&lt;/p&gt;
&lt;p&gt;3NF：不存在非主属性对码的传递函数依赖&lt;/p&gt;
&lt;p&gt;BCNF：主键有可能是由多个主属性组合成的复合主键，那么多个主属性之间不能有传递依赖&lt;/p&gt;
&lt;h4 id=&#34;连接&#34;&gt;连接&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自然连接（natural join）&lt;/strong&gt;
自然连接是一种特殊的等值连接，他要求两个关系表中进行比较的必须是相同的属性列，无须添加连接条件，并且在结果中消除重复的属性列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内连接（inner join）&lt;/strong&gt;
内连接基本与自然连接相同，不同之处在于自然连接要求是同名属性列的比较，而内连接则不要求两属性列同名，可以用using或on来指定某两列字段相同的连接条件。&lt;/p&gt;
&lt;p&gt;平常from &amp;hellip; where &amp;hellip; = &amp;hellip;虽然没有指明是inner join但实际上就是内连接&lt;/p&gt;
&lt;p&gt;如果是join，默认就是inner join&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;左外连接（left outer join)&lt;/strong&gt;
左外连接是在两表进行自然连接，只把左表要舍弃的保留在结果集中，右表对应的列上填null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右外连接(rignt outer join)&lt;/strong&gt;
右外连接是在两表进行自然连接，只把右表要舍弃的保留在结果集中，左表对应的列上填null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全外连接(full join)&lt;/strong&gt;
全外连接是在两表进行自然连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null。&lt;/p&gt;
&lt;h4 id=&#34;联合查询&#34;&gt;联合查询&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;联合查询结果是将多个select语句的查询结果合并到一块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如现在需要查询两个公司的所有员工的信息，这就需要从甲公司查询所有员工信息，再从乙公司查询所有的员工信息，然后将两次的查询结果进行合并。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法格式如下:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;语句&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;选项&lt;/span&gt;]
&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;语句&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;union&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;选项&lt;/span&gt;]
&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;语句&lt;/span&gt;n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中union选项有两个选项可选&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;all：表示无论重复都输出&lt;/li&gt;
&lt;li&gt;distinct: 去重(整个重复)（默认的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将同一张表中不同的结果（需要对应多条查询语句来实现），合并到一起展示数据&lt;/li&gt;
&lt;li&gt;最常见：在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合查询来将数据存放到一起显示&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务&#34;&gt;事务&lt;/h3&gt;
&lt;h4 id=&#34;数据库什么是事务&#34;&gt;数据库什么是事务？&lt;/h4&gt;
&lt;p&gt;事务是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。&lt;/p&gt;
&lt;h4 id=&#34;事务有哪四个特性分别表示什么含义&#34;&gt;事务有哪四个特性？分别表示什么含义？&lt;/h4&gt;
&lt;p&gt;A：原子性
事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出全部成功执行或者全部不执行。&lt;/p&gt;
&lt;p&gt;C：一致性
事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态。&lt;/p&gt;
&lt;p&gt;I：隔离性
事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。也就是说，不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/p&gt;
&lt;p&gt;D：持久性
事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。换句话说，一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。&lt;/p&gt;
&lt;h4 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h4&gt;
&lt;p&gt;未提交读：允许读取未提交数据&lt;/p&gt;
&lt;p&gt;已提交读：只允许读取已提交数据，但不要求可重复读；比如在该事务两次读取一个数据项期间，另一个事务更新了该数据并提交&lt;/p&gt;
&lt;p&gt;可重复读：只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，不允许其它事务更新该数据；但不要求可串行化，例如当一个事务在查找满足某些条件的数据时，它可能找到一个已提交事务插入的一些数据（不是改变原有数据所以不会被锁住），但找不到该事务插入的其它数据&lt;/p&gt;
&lt;p&gt;可串行化：通常保证可串行化调度，等价于一个串行调度&lt;/p&gt;
&lt;p&gt;脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。&lt;/p&gt;
&lt;p&gt;不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。&lt;/p&gt;
&lt;p&gt;幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200614194013390.png&#34; alt=&#34;image-20200614194013390&#34;&gt;&lt;/p&gt;
&lt;p&gt;Note：不可重复读用MVCC可解；幻读加间隙锁可解&lt;/p&gt;
&lt;h4 id=&#34;事务是怎么实现的&#34;&gt;事务是怎么实现的&lt;/h4&gt;
&lt;p&gt;事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的&lt;strong&gt;持久性&lt;/strong&gt;。undo log记录的是事务修改之前的数据信息，用来回滚数据&lt;/li&gt;
&lt;li&gt;并发控制：并发控制主要靠锁和来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;redo-log--undo-log&#34;&gt;redo log &amp;amp; undo log&lt;/h4&gt;
&lt;p&gt;undolog用于回滚，redolog用于前滚&lt;/p&gt;
&lt;p&gt;前滚：事务提交之后，部分数据写入了磁盘，但是还有部分数据存在脏页上，并没有写入磁盘。此时设备宕机，没有写入磁盘的数据丢失。就要依赖redolog来恢复这部分数据。&lt;/p&gt;
&lt;p&gt;回滚：事务还未提交，改动并没有完全生效，但是记录已经被修改。此时设备宕机，数据是有问题的，就要依赖undolog回滚改动。&lt;/p&gt;
&lt;h4 id=&#34;死锁处理&#34;&gt;死锁处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;预防死锁&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;保证事务之间的等待不会出现环，也就是事务之间的等待图应该是一张&lt;strong&gt;有向无环图&lt;/strong&gt;，没有循环等待的情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用抢占加事务回滚的方式预防死锁，当事务开始执行时会先获得一个时间戳，数据库程序会根据事务的时间戳决定事务应该等待还是回滚&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wait-die：年老事务等待年轻事务释放对应资源的锁；年轻事务不等待年老事务，而是直接回滚&lt;/li&gt;
&lt;li&gt;wound-wait：年老事务抢占年轻事务的资源并强制年轻事务回滚；年轻事务等待年老事务释放对应资源的锁&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;死锁检测和恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死锁检测：超时 / 等待图出现环&lt;/p&gt;
&lt;p&gt;死锁恢复：全部回滚（回滚整个事务） / 部分回滚（回滚到可以解除死锁的状态）&lt;/p&gt;
&lt;h4 id=&#34;mvcc多版本控制机制&#34;&gt;MVCC（多版本控制机制）&lt;/h4&gt;
&lt;p&gt;在MySQL中建表时，每个表都会有三列隐藏记录，其中和MVCC有关系的有两列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据行的版本号 （DB_TRX_ID）&lt;/li&gt;
&lt;li&gt;删除版本号 (DB_ROLL_PT)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200922231235923.png&#34; alt=&#34;image-20200922231235923&#34;&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200922231246522.png&#34; alt=&#34;image-20200922231246522&#34;&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200922231258357.png&#34; alt=&#34;image-20200922231258357&#34;&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200922231327307.png&#34; alt=&#34;image-20200922231327307&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;索引&#34;&gt;索引&lt;/h3&gt;
&lt;h4 id=&#34;b树-b树区别&#34;&gt;B+树 B树区别&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906171158001.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;B+tree 是 B-tree 的变种，B+tree 数据只存储在叶子节点中。这样在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;&lt;/p&gt;
&lt;p&gt;与B树区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。&lt;/li&gt;
&lt;li&gt;分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针，内部结点仅仅包含着索引信息。&lt;/li&gt;
&lt;li&gt;查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b树优点&#34;&gt;B+树优点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;B+树的磁盘读写代价更低&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+树查询效率更加稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+树便于范围查询（最重要的原因，范围查找是数据库的常态）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低&lt;/p&gt;
&lt;h4 id=&#34;b树增加删除&#34;&gt;B+树增加删除&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223004030.png&#34; alt=&#34;image-20201017223004030&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223024604.png&#34; alt=&#34;image-20201017223024604&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223044715.png&#34; alt=&#34;image-20201017223044715&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223102719.png&#34; alt=&#34;image-20201017223102719&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223115728.png&#34; alt=&#34;image-20201017223115728&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223136366.png&#34; alt=&#34;image-20201017223136366&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017223156522.png&#34; alt=&#34;image-20201017223156522&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;索引类型&#34;&gt;索引类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚集索引（主索引）： 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非聚集索引（辅助索引）：数据在物理存储中的顺序跟索引中数据的逻辑顺序不同&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;聚簇索引的叶子节点存储了一行完整的数据，而二级索引只存储了主键值，相比于聚簇索引，占用的空间要少。当我们需要为表建立多个索引时，如果都是聚簇索引，那将占用大量内存空间，所以InnoDB中主键所建立的是聚簇索引，而唯一索引、普通索引、前缀索引等都是二级索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;稠密索引：文件中的每个搜索码值都对应一个索引值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稀疏索引：只为搜索码的某些值建立索引项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;聚集索引可以是稀疏索引，非聚集索引必须是稠密索引（不然找不到，非聚集索引不按顺序）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;哈希索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此&lt;strong&gt;哈希索引不支持范围查找和排序的功能&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全文索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;B+树索引（见下文）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;什么情况下不适合建立索引&#34;&gt;什么情况下不适合建立索引&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于在查询过程中很少使用或参考的列，不应该创建索引。&lt;/li&gt;
&lt;li&gt;对于那些只有很少数据值的列，不应该创建索引。&lt;/li&gt;
&lt;li&gt;对于那些定义为image，text和bit数据类型的列，不应该创建索引。&lt;/li&gt;
&lt;li&gt;当修改性能远大于检索性能，不应该建立索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;主键和索引比较&#34;&gt;主键和索引比较&lt;/h4&gt;
&lt;p&gt;1.主键为一种约束，唯一索引为一种索引，本质上就不同。&lt;/p&gt;
&lt;p&gt;2.主键在表中只能有一个，唯一索引可以有多个。&lt;/p&gt;
&lt;p&gt;3.主键创建后一定包含唯一性索引，而唯一索引不一定就是主键。&lt;/p&gt;
&lt;p&gt;4.主键不能为null,唯一索引可以为null.&lt;/p&gt;
&lt;p&gt;5.主键可以被其它表引用，唯一索引不能。&lt;/p&gt;
&lt;p&gt;6.主键和索引都是键，主键是逻辑键，索引为物理键，即主键不实际存在。&lt;/p&gt;
&lt;h4 id=&#34;索引作用&#34;&gt;索引作用&lt;/h4&gt;
&lt;p&gt;正面影响&lt;/p&gt;
&lt;p&gt;快速访问数据表中的特定信息，提高检索速度；创建唯一性索引，保证数据库表中每一行数据的唯一性；加速表和表之间的连接；使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间&lt;/p&gt;
&lt;p&gt;负面影响：&lt;/p&gt;
&lt;p&gt;创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。&lt;/p&gt;
&lt;h4 id=&#34;索引失效&#34;&gt;索引失效&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;违背最左匹配&lt;/li&gt;
&lt;li&gt;在索引上做计算、函数、自动/手动类型转换等操作&lt;/li&gt;
&lt;li&gt;使用范围条件（bettween、&amp;lt;、&amp;gt;、in等）&lt;/li&gt;
&lt;li&gt;索引字段上使用！，=，&amp;lt;，&amp;gt;，is null / is not null，like判断时&lt;/li&gt;
&lt;li&gt;使用 or 并且一个字段没加索引时&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联合索引最左匹配&#34;&gt;联合索引&amp;amp;最左匹配&lt;/h4&gt;
&lt;p&gt;对于复合索引（多列b+tree，使用多列值组合而成的b+tree索引）。遵循最左侧原则，从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a  a,b a,b,c 3种组合进行查找，但不支持 b,c进行查找。当使用最左侧字段时，索引就十分有效。&lt;/p&gt;
&lt;p&gt;比如(a,b,c)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(a=? and b=? and c=?)这样的数据来检索的时候，b+树会优先比较a列来确定下一步的所搜方向，如果a列相同再依次比较b列和c列，最后得到检索的数据；但当(b=? and c=?)这样的没有a列的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候a列就是第一个比较因子，必须要先根据a列来搜索才能知道下一步去哪里查询。比如当(a=? and c=?)这样的数据来检索时，b+树可以用a列来指定搜索方向，但下一个字段b列的缺失，所以只能把a列的数据找到，然后再匹配c列的数据了， 这个是非常重要的性质，&lt;strong&gt;即索引的最左匹配特性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;联合索引遇到范围查询也会停止，例如a=1, c&amp;lt;2，a仍然可以命中索引，但bc就不行了&lt;/p&gt;
&lt;h3 id=&#34;mysql&#34;&gt;Mysql&lt;/h3&gt;
&lt;h4 id=&#34;mysql引擎&#34;&gt;Mysql引擎&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906173116788.png&#34; alt=&#34;image-20200906173116788&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。&lt;/p&gt;
&lt;p&gt;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。&lt;/p&gt;
&lt;p&gt;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。&lt;/p&gt;
&lt;p&gt;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。&lt;/p&gt;
&lt;p&gt;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。&lt;/p&gt;
&lt;p&gt;提供了大量的特性，包括压缩表、空间数据索引等。&lt;/p&gt;
&lt;p&gt;不支持事务。&lt;/p&gt;
&lt;p&gt;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。&lt;/p&gt;
&lt;p&gt;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。&lt;/p&gt;
&lt;p&gt;如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。&lt;/p&gt;
&lt;p&gt;比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。&lt;/li&gt;
&lt;li&gt;并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。&lt;/li&gt;
&lt;li&gt;外键：InnoDB 支持外键。&lt;/li&gt;
&lt;li&gt;备份：InnoDB 支持在线热备份。&lt;/li&gt;
&lt;li&gt;崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。&lt;/li&gt;
&lt;li&gt;其它特性：MyISAM 支持压缩表和空间数据索引。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mysql锁&#34;&gt;Mysql锁&lt;/h4&gt;
&lt;h4 id=&#34;切分&#34;&gt;切分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017222332505.png&#34; alt=&#34;image-20201017222332505&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017222349230.png&#34; alt=&#34;image-20201017222349230&#34;&gt;&lt;/p&gt;
&lt;p&gt;Sharding 存在的问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用分布式事务来解决，比如 XA 接口。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;ID 唯一性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用全局唯一 ID（GUID）&lt;/p&gt;
&lt;p&gt;为每个分片指定一个 ID 范围&lt;/p&gt;
&lt;p&gt;分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)&lt;/p&gt;
&lt;h4 id=&#34;mysql不同引擎锁的区别&#34;&gt;Mysql不同引擎锁的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）&lt;/li&gt;
&lt;li&gt;InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如Web 应用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最大程度的支持并发，同时也带来了最大的锁开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行级锁只在存储引擎层实现，而Mysql服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mysql有哪些锁&#34;&gt;Mysql有哪些锁&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;读写锁（行锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读锁，又称共享锁（Share locks，简称 S 锁），加了读锁的记录，所有的事务都可以读取，但是不能修改，并且可同时有多个事务对记录加读锁。&lt;/p&gt;
&lt;p&gt;写锁，又称排他锁（Exclusive locks，简称 X 锁），或独占锁，对记录加了排他锁之后，只有拥有该锁的事务可以读取和修改，其他事务都不可以读取和修改，并且同一时间只能有一个事务加写锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读写意向锁（表锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于表锁和行锁虽然锁定范围不同，但是会相互冲突。所以当你要加表锁时，势必要先遍历该表的所有记录，判断是否加有排他锁。这种遍历检查的方式显然是一种低效的方式，MySQL 引入了意向锁，来检测表锁和行锁的冲突。&lt;/p&gt;
&lt;p&gt;意向锁也是表级锁，也可分为读意向锁（IS 锁）和写意向锁（IX 锁）。当事务要在记录上加上读锁或写锁时，要首先在表上加上意向锁。这样判断表中是否有记录加锁就很简单了，只要看下表上是否有意向锁就行了。&lt;/p&gt;
&lt;p&gt;意向锁之间是不会产生冲突的，也不和 AUTO_INC 表锁冲突，它只会阻塞表级读锁或表级写锁，另外，意向锁也不会和行锁冲突，行锁只会和行锁冲突。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自增锁（表锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AUTOINC 锁又叫自增锁（一般简写成 AI 锁），是一种表锁，当表中有自增列（AUTOINCREMENT）时出现。当插入表中有自增列时，数据库需要自动生成自增值，它会先为该表加 AUTOINC 表锁，阻塞其他事务的插入操作，这样保证生成的自增值肯定是唯一的。AUTOINC 锁具有如下特点：&lt;/p&gt;
&lt;p&gt;AUTO_INC 锁互不兼容，也就是说同一张表同时只允许有一个自增锁；&lt;/p&gt;
&lt;p&gt;自增值一旦分配了就会 +1，如果事务回滚，自增值也不会减回去，所以自增值可能会出现中断的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;记录锁（行锁）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录锁是最简单的行锁，并没有什么好说的。上边描述 InnoDB 加锁原理中的锁就是记录锁，只锁住 id = 49 或者 name = &amp;lsquo;Tom&amp;rsquo; 这一条记录。&lt;/p&gt;
&lt;p&gt;当 SQL 语句无法使用索引时，会进行全表扫描，这个时候 MySQL 会给整张表的所有数据行加记录锁，再由 MySQL Server 层进行过滤。但是，在 MySQL Server 层进行过滤的时候，如果发现不满足 WHERE 条件，会释放对应记录的锁。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。&lt;/p&gt;
&lt;p&gt;所以更新操作必须要根据索引进行操作，没有索引时，不仅会消耗大量的锁资源，增加数据库的开销，还会极大的降低了数据库的并发性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;间隙锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是最开始更新用户年龄的例子，如果 id = 49 这条记录不存在，这个 SQL 语句还会加锁吗？答案是可能有，这取决于数据库的隔离级别。这种情况下，在 RC 隔离级别不会加任何锁，在 RR 隔离级别会在 id = 49 前后两个索引之间加上间隙锁。&lt;/p&gt;
&lt;p&gt;间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。这个间隙可以跨一个索引记录，多个索引记录，甚至是空的。&lt;strong&gt;使用间隙锁可以防止其他事务在这个范围内插入或修改记录，保证两次读取这个范围内的记录不会变，从而不会出现幻读现象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是，间隙锁和间隙锁之间是互不冲突的，间隙锁唯一的作用就是为了防止其他事务的插入，所以加间隙 S 锁和加间隙 X 锁没有任何区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;临键锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next-key锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。假设一个索引包含 15、18、20 ，30，49，50 这几个值，可能的 Next-key 锁如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;(-∞, 15]，(15, 18]，(18, 20]，(20, 30]，(30, 49]，(49, 50]，(50, +∞)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通常我们都用这种左开右闭区间来表示 Next-key 锁，其中，圆括号表示不包含该记录，方括号表示包含该记录。前面四个都是 Next-key 锁，最后一个为间隙锁。和间隙锁一样，在 RC 隔离级别下没有 Next-key 锁，只有 RR 隔离级别才有。还是之前的例子，如果 id 不是主键，而是二级索引，且不是唯一索引，那么这个 SQL 在 RR 隔离级别下就会加如下的 Next-key 锁 (30, 49](49, 50)&lt;/p&gt;
&lt;p&gt;此时如果插入一条 id = 31 的记录将会阻塞住。之所以要把 id = 49 前后的间隙都锁住，仍然是为了解决幻读问题，因为 id 是非唯一索引，所以 id = 49 可能会有多条记录，为了防止再插入一条 id = 49 的记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入意向锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;插入意向锁是一种特殊的间隙锁（简写成 II GAP）表示插入的意向，只有在 INSERT 的时候才会有这个锁。注意，这个锁虽然也叫意向锁，但是和上面介绍的表级意向锁是两个完全不同的概念，不要搞混了。&lt;/p&gt;
&lt;p&gt;插入意向锁和插入意向锁之间互不冲突，所以可以在同一个间隙中有多个事务同时插入不同索引的记录。譬如在上面的例子中，id = 30 和 id = 49 之间如果有两个事务要同时分别插入 id = 32 和 id = 33 是没问题的，虽然两个事务都会在 id = 30 和 id = 50 之间加上插入意向锁，但是不会冲突。&lt;/p&gt;
&lt;p&gt;插入意向锁只会和间隙锁或 Next-key 锁冲突，正如上面所说，间隙锁唯一的作用就是防止其他事务插入记录造成幻读，正是由于在执行 INSERT 语句时需要加插入意向锁，而插入意向锁和间隙锁冲突，从而阻止了插入操作的执行。&lt;/p&gt;
&lt;h4 id=&#34;mysql加锁&#34;&gt;Mysql加锁&lt;/h4&gt;
&lt;p&gt;意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过以下语句显示给记录集加共享锁或排他锁。&lt;/p&gt;
&lt;p&gt;共享锁（S）：SELECT * FROM table_name WHERE &amp;hellip; LOCK IN SHARE MODE。&lt;/p&gt;
&lt;p&gt;排他锁（X)：SELECT * FROM table_name WHERE &amp;hellip; FOR UPDATE。&lt;/p&gt;
&lt;h4 id=&#34;innodb行锁实现方式&#34;&gt;InnoDB行锁实现方式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;InnoDB行锁是通过给索引上的索引项加锁来实现的&lt;/strong&gt;，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁&lt;/p&gt;
&lt;h4 id=&#34;查询性能优化&#34;&gt;查询性能优化&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;优化数据访问&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;减少请求的数据量：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只返回必要的列：最好不要使用 SELECT * 语句。&lt;/p&gt;
&lt;p&gt;只返回必要的行：使用 LIMIT 语句来限制返回的数据。&lt;/p&gt;
&lt;p&gt;缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少服务器端扫描的行数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用索引来覆盖查询。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;重构查询方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;切分大查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;DELETE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt; messages &lt;span style=&#34;color:#66d9ef&#34;&gt;WHERE&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DATE_SUB&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;NOW&lt;/span&gt;(), &lt;span style=&#34;color:#66d9ef&#34;&gt;INTERVAL&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt; MONTH);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;改成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;rows_affected &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
do &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;{&lt;/span&gt;
    rows_affected &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_query&lt;/span&gt;(
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;DELETE FROM messages WHERE create  &amp;lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; rows_affected &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;分解大连接查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。&lt;/li&gt;
&lt;li&gt;分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。&lt;/li&gt;
&lt;li&gt;减少锁竞争；&lt;/li&gt;
&lt;li&gt;在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;innodb如何建立主键&#34;&gt;InnoDB如何建立主键&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果一个主键被定义了，那么这个主键就是作为聚集索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，该列的值会随着数据的插入自增。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;为什么主键最好是自增主键&#34;&gt;为什么主键最好是自增主键&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017215529486.png&#34; alt=&#34;image-20201017215529486&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201017215552811.png&#34; alt=&#34;image-20201017215552811&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;mysql执行一个查询的过程&#34;&gt;MySQL执行一个查询的过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送一个查询给服务器。&lt;/li&gt;
&lt;li&gt;服务器先检查查询缓存，如果命中，则直接返回缓存中的结果。如果没有没有命中，则进入下一阶段（解析器）。&lt;/li&gt;
&lt;li&gt;服务器由解析器检查sql语法是否正确，然后由预处理器检查sql中的表和字段是否存在，最后由查询优器生成执行计划。这一步很耗资源。&lt;/li&gt;
&lt;li&gt;mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。&lt;/li&gt;
&lt;li&gt;将结果返回给客户端。&lt;/li&gt;
&lt;/ol&gt;

        
      </description>
    </item>
    
    <item>
      <title>Computer Network</title>
      <link>https://president810.github.io/Cpp-Interview-Notes/interview/computernetwork/</link>
      <pubDate>Thu, 24 Dec 2020 23:35:01 +0800</pubDate>
      
      <guid>https://president810.github.io/Cpp-Interview-Notes/interview/computernetwork/</guid>
      <description>
        
          &lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;
&lt;h3 id=&#34;osi七层模型&#34;&gt;OSI七层模型&lt;/h3&gt;
&lt;h4 id=&#34;协议作用&#34;&gt;协议，作用&lt;/h4&gt;
&lt;p&gt;物理层：建立、维护、断开物理连接&lt;/p&gt;
&lt;p&gt;提供物理连接；实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么&lt;/p&gt;
&lt;p&gt;链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能&lt;/p&gt;
&lt;p&gt;建立管理节点间的链路；接受来自物理层的比特流形式的数据并封装成帧传送到上一层，将来自上层的数据帧拆装为比特流形式的数据发送给物理层；通过mac地址在网络内部找到host&lt;/p&gt;
&lt;p&gt;网络层：进行逻辑地址寻址，实现不同网络之间的路径选择&lt;/p&gt;
&lt;p&gt;通过路由选择算法为报文或分组通过通信子网选择最适当的路径；链路层数据帧在网络层被转换为数据包，在不同网络中进行传输；在不同网络间通信时通过唯一的ip地址（逻辑地址）识别设备，通过路由器连接不同的网络并计算出传送路径&lt;/p&gt;
&lt;p&gt;传输层：建立，管理和维护端到端的连接&lt;/p&gt;
&lt;p&gt;定义了传输数据的协议及端口号（TCP传输效率低可靠性高，发消息等允许延迟不允许丢包，UDP效率高可靠性低，视频聊天等允许丢包不允许延迟），将从下层接受到的数据进行分段和传输，到达目的地址之后再重组，同时进行流量控制，根据接收方接收数据的快慢程度，规定适当的发送速率，解决传输效率及能力的问题&lt;/p&gt;
&lt;p&gt;会话层，表示层不提了&lt;/p&gt;
&lt;p&gt;应用层：网络服务与最终用户的一个接口，规定应用程序如何进行通信&lt;/p&gt;
&lt;p&gt;直接向用户的应用程序提供网络服务，进行文件传输，文件管理，电子邮件的信息处理&lt;/p&gt;
&lt;h3 id=&#34;ip&#34;&gt;IP&lt;/h3&gt;
&lt;h4 id=&#34;ip-packet&#34;&gt;IP Packet&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201019001122320.png&#34; alt=&#34;image-20201019001122320&#34;&gt;&lt;/p&gt;
&lt;p&gt;Version：版本号&lt;/p&gt;
&lt;p&gt;Header length：头长度&lt;/p&gt;
&lt;p&gt;Type of service：服务类型&lt;/p&gt;
&lt;p&gt;Datagram length：数据报长度&lt;/p&gt;
&lt;p&gt;Identifier, flags, fragmentation offset：用来分片（IP fragmentation），链路层有最大传输限制（MTU），通过分片保证IP包可以分成符合MTU的小片从而在不同局域网之间传输&lt;/p&gt;
&lt;p&gt;Time-to-live：确保ip packet不会在网络中一直被传下去&lt;/p&gt;
&lt;p&gt;Protocol：传输层用的啥协议&lt;/p&gt;
&lt;p&gt;Header checksum：校验用的&lt;/p&gt;
&lt;p&gt;Source and destination IP addresses：两边的ip地址&lt;/p&gt;
&lt;p&gt;Options：一般不用&lt;/p&gt;
&lt;h4 id=&#34;arp协议&#34;&gt;ARP协议&lt;/h4&gt;
&lt;p&gt;ARP协议是用来在局域网内找IP对应的MAC的&lt;/p&gt;
&lt;p&gt;源主机先在自己的ARP缓冲区中寻找映射，如果有（直接填充于以太网帧中），如果没有，通过路由广播向局域网内每一台主机进行请求，这时一些联网的主机就会收到这个请求，并将这个请求传回网络层，对比IP地址，检验是否可以接受，如果不行，则直接丢失这个信息，如果可以那么回复ARP请求，并且将源主机的MAC地址加入到目的ARP缓冲区中，形成映射，源主机接受到请求后，将目的的MAC地址加入到ARP缓冲区，也形成映射，并将mac地址传输至连接层。此时转化完成&lt;/p&gt;
&lt;h3 id=&#34;tcpudp&#34;&gt;TCP/UDP&lt;/h3&gt;
&lt;h4 id=&#34;tcpudp区别应用场景&#34;&gt;TCP，UDP区别，应用场景&lt;/h4&gt;
&lt;p&gt;TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接（三次握手/四次挥手），丢包重发，分包顺序乱了会进行顺序控制；提供拥塞控制 UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，传输数据之前源端和终端不建立连接。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。没有拥塞控制，（网络出现拥塞不会使源主机的发送速率降低），丢包不重发。包的到达顺序乱掉也不纠正。&lt;/p&gt;
&lt;p&gt;1、TCP面向连接，需要先建立连接；UDP是无连接的，即发送数据之前不需要建立连接&lt;/p&gt;
&lt;p&gt;2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付&lt;/p&gt;
&lt;p&gt;3、TCP面向字节流，当应用程序传送的数据块太长会把它划分短一些再传送，如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去；UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送&lt;/p&gt;
&lt;p&gt;4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信&lt;/p&gt;
&lt;p&gt;5、TCP首部开销20字节；UDP的首部开销小只有8个字节&lt;/p&gt;
&lt;p&gt;TCP用于在传输层有必要实现可靠传输的情况：SMTP，SSH，HTTP，FTP，&lt;/p&gt;
&lt;p&gt;UDP用于那些对高速传输和实时性有较高要求的通信或广播通信：DNS，TFTP&lt;/p&gt;
&lt;h4 id=&#34;tcp-segment&#34;&gt;TCP segment&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906144635122.png&#34; alt=&#34;image-20200906144635122&#34;&gt;&lt;/p&gt;
&lt;p&gt;Sequence &amp;amp; Acknowledgment：确保可靠传输&lt;/p&gt;
&lt;p&gt;Receive window：流量控制&lt;/p&gt;
&lt;p&gt;Header length：TCP头部长度（options一般为空，所以长度一般为20bytes）&lt;/p&gt;
&lt;p&gt;Option field：用于协商MSS&lt;/p&gt;
&lt;p&gt;ACK：Acknowledgment是否有效&lt;/p&gt;
&lt;p&gt;RST &amp;amp; SYN &amp;amp; FIN：三次握手四次挥手&lt;/p&gt;
&lt;p&gt;PSH &amp;amp; URG：一般不用&lt;/p&gt;
&lt;p&gt;Urgent data pointer：提示紧急信息位置&lt;/p&gt;
&lt;p&gt;Internet checksum：校验和&lt;/p&gt;
&lt;h4 id=&#34;udp-segment&#34;&gt;UDP segment&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906145135895.png&#34; alt=&#34;image-20200906145135895&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;三次握手四次挥手&#34;&gt;三次握手/四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906023622926.png&#34; alt=&#34;image-20200906023622926&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一次握手：主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B，向主机B 请求建立连接，通过这个数据段， 主机A告诉主机B 两件事：我想要和你通信，你可以用哪个序列号作为起始数据段来回应我&lt;/p&gt;
&lt;p&gt;第二次握手：主机B 收到主机A的请求后，用一个带有确认应答和同步序列号标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我&lt;/p&gt;
&lt;p&gt;第三次握手：主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B 的数据段：我已收到回复，我现在要开始传输实际数据了，这样3次握手就完成了，主机A和主机B 就可以传输数据了&lt;/p&gt;
&lt;p&gt;TCP建立连接要进行3次握手，而断开连接要进行4次&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://pic3.zhimg.com/80/v2-db5c6c352000712920657d39059416f6_1440w.jpg&#34; alt=&#34;img&#34;&gt;&lt;/p&gt;
&lt;p&gt;第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ；&lt;/p&gt;
&lt;p&gt;第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；&lt;/p&gt;
&lt;p&gt;第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；&lt;/p&gt;
&lt;p&gt;第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束.。&lt;/p&gt;
&lt;p&gt;seq：序列号，传了多少数据&lt;/p&gt;
&lt;p&gt;ACK：确认字段，仅当ACK=1时确认号字段有效，连接建立后所有传送报文段ACK=1&lt;/p&gt;
&lt;p&gt;ack number：确认号码，为N表示N-1为止所有数据都正确收到&lt;/p&gt;
&lt;p&gt;SYN：发起一个连接。在握手完成后SYN为1，表示TCP建立已连接。此后的所有报文段中，SYN都被置0。&lt;/p&gt;
&lt;p&gt;FIN：释放一个连接。如果源主机数据发送完毕，将把该连接下要发送的最后一个报文段的报头中的FIN位置1，或将该报文段后面发送的报头中该位置1。&lt;/p&gt;
&lt;h4 id=&#34;为啥要三次握手&#34;&gt;为啥要三次握手&lt;/h4&gt;
&lt;p&gt;client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”&lt;/p&gt;
&lt;h4 id=&#34;为什么建立连接协议是三次握手而关闭连接却是四次握手呢&#34;&gt;为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？&lt;/h4&gt;
&lt;p&gt;这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，**它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，**所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。&lt;/p&gt;
&lt;h4 id=&#34;rst是干啥的&#34;&gt;RST是干啥的&lt;/h4&gt;
&lt;p&gt;三次握手中第三次的ACK丢失，导致Client认为连接已经建立但是实际上并没有建立连接时，Client向server发包，server会用RST回应，表示连接尚未建立&lt;/p&gt;
&lt;h4 id=&#34;tcp协议如何确保可靠性传输&#34;&gt;TCP协议如何确保可靠性传输&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;（校序重流拥）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;确认应答+序列号：TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906005330499.png&#34; alt=&#34;image-20200906005330499&#34;&gt;&lt;/p&gt;
&lt;p&gt;超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。&lt;/p&gt;
&lt;p&gt;EstimatedRTT = (1 – a 􏰂) • EstimatedRTT + 􏰂 a • SampleRTT&lt;/p&gt;
&lt;p&gt;DevRTT = (1 – b 􏰃) • DevRTT + b • | SampleRTT – EstimatedRTT |&lt;/p&gt;
&lt;p&gt;TimeoutInterval = EstimatedRTT + 4 • DevRTT&lt;/p&gt;
&lt;p&gt;校验和：在发送方将整个报文段分为多个16位的段，然后将所有段进行反码相加，将结果存放在检验和字段中，接收方用相同的方法进行计算，如最终结果为检验字段所有位是全1则正确&lt;/p&gt;
&lt;p&gt;连接管理：三次握手四次挥手。&lt;/p&gt;
&lt;p&gt;如上&lt;/p&gt;
&lt;p&gt;流量控制：   TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失&lt;/p&gt;
&lt;p&gt;LastByteRcvd – LastByteRead &amp;lt;= 􏰄 RcvBuffer&lt;/p&gt;
&lt;p&gt;rwnd = RcvBuffer – [LastByteRcvd – LastByteRead]&lt;/p&gt;
&lt;p&gt;LastByteSent – LastByteAcked &amp;lt;= 􏰄 rwnd&lt;/p&gt;
&lt;p&gt;拥塞控制：当网络拥塞时，减少数据的发送&lt;/p&gt;
&lt;h4 id=&#34;time_wait的意义为什么要等于2msl&#34;&gt;TIME_WAIT的意义（为什么要等于2MSL）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;可靠的终止TCP连接&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;若处于time_wait的client发送给server确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态就是time_wait而不是close状态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证迟来的TCP报文段有足够的时间被识别并丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;linux 中一个TCPport不能打开两次或两次以上。当client处于time_wait状态时我们将无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会收到旧连接的数据；2MSL可以保证所有旧连接的数据在这个过程中全部死亡&lt;/p&gt;
&lt;p&gt;time_wait持续的时间是2MSL，保证旧的数据能够丢弃。由于网络中的数据最大存在MSL(maxinum segment lifetime)&lt;/p&gt;
&lt;h4 id=&#34;为什么序列号要随机初始化&#34;&gt;为什么序列号要随机初始化&lt;/h4&gt;
&lt;p&gt;minimize the possibility that a segment that is still present in the network from an earlier, already-terminated connection between two hosts is mistaken for a valid segment in a later connection between these same two hosts (which also hap- pen to be using the same port numbers as the old connection)&lt;/p&gt;
&lt;h4 id=&#34;udp如何实现可靠传输&#34;&gt;UDP如何实现可靠传输&lt;/h4&gt;
&lt;p&gt;因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。&lt;/p&gt;
&lt;p&gt;就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性&lt;/p&gt;
&lt;h4 id=&#34;流量控制&#34;&gt;流量控制&lt;/h4&gt;
&lt;p&gt;所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。&lt;/p&gt;
&lt;p&gt;问题：接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。&lt;/p&gt;
&lt;p&gt;解决这个问题：只要TCP的一方收到对方的零窗口通知，就周期性的发送一个1 byte的零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）&lt;/p&gt;
&lt;h4 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h4&gt;
&lt;p&gt;TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复&lt;/p&gt;
&lt;p&gt;发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。&lt;/p&gt;
&lt;p&gt;ssthresh：慢开始阈值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;慢启动：慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16 MSS
为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &amp;gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法&lt;/li&gt;
&lt;li&gt;拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1 MSS，而不是加倍。&lt;/li&gt;
&lt;li&gt;快速重传：当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为cwnd一半，拥塞窗口cwnd变为ssth+3 MSS，然后+1+1的发（每一轮rtt+1 MSS）&lt;/li&gt;
&lt;li&gt;快速恢复：当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为cwnd一半，拥塞窗口cwnd=1 MSS，进入慢启动阶段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MSS: maximum segment size，等于MTU减去-TCP/IP头部的大小&lt;/p&gt;
&lt;h4 id=&#34;粘包如何解决&#34;&gt;粘包如何解决&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201019004554644.png&#34; alt=&#34;image-20201019004554644&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加报文长度&lt;/li&gt;
&lt;li&gt;每个报文结尾加分隔符&lt;/li&gt;
&lt;li&gt;报文设置固定长度&lt;/li&gt;
&lt;li&gt;发送方关闭nagle算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;socket是什么经常使用吗&#34;&gt;SOCKET是什么，经常使用吗？&lt;/h4&gt;
&lt;p&gt;socket是应用层与传输层的一个抽象，将复杂的TCP/IP协议隐藏在Socket接口之后，只对应用层暴露简单的接口&lt;/p&gt;
&lt;p&gt;socket是一种特殊的文件，它也有文件描述符，进程可以打开一个socket，并且像处理文件一样对它进行read()和write()操作，而不必关心数据是怎么在网络上传输的&lt;/p&gt;
&lt;p&gt;socket是一个tcp连接的两端，网络层的ip地址唯一标识一台主机，而传输层的协议+端口号可以唯一标识绑定到这个端口的进程&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;socket编程中listen和accept的区别&#34;&gt;socket编程中listen()和accept()的区别&lt;/h4&gt;
&lt;p&gt;int listen(int sockfd, int backlog)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;:listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。&lt;/p&gt;
&lt;p&gt;listen函数在一般在调用bind之后-调用accept之前调用，它的函数原型是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数sockfd&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;被listen函数作用的套接字，sockfd之前由socket函数返回。在被socket函数返回的套接字fd之时，它是一个主动连接的套接字，也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，用户进程通过系统调用listen来完成这件事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数backlog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个参数涉及到一些网络的细节。进程处理一个一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。如果这个情况出现了，服务器进程希望内核如何处理呢？内核会在自己的进程空间里维护一个队列以跟踪这些完成的连接但服务器进程还没有接手处理或正在进行的连接，这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限。这个backlog告诉内核使用这个数值作为上限。&lt;/p&gt;
&lt;p&gt;int accept(int s, struct sockaddr * addr, int * addrlen)&lt;/p&gt;
&lt;p&gt;服务程序调用accept函数，从处于监听状态的socket的客户连接请求队列中，取出排在最前的一个客户请求，并且&lt;strong&gt;创建一个新的套接字&lt;/strong&gt;来与客户套接字创建连接通道，如果连接成功，就返回新创建的套接字的描述符，以后与客户套接字交换数据的是新创建的套接字；如果失败就返回 INVALID_SOCKET。&lt;/p&gt;
&lt;p&gt;该函数的第一个参数指定处于监听状态的流套接字；操作系统利用第二个参数来返回新创建的套接字的地址结构；操作系统利用第三个参数来返回新创建的套接字的地址结构的长度。&lt;/p&gt;
&lt;p&gt;listen函数不会阻塞，它只是相当于把socket的属性更改为被动连接，可以接收其他进程的连接。listen侦听的过程并不是一直阻塞，直到有客户端请求连接才会返回，它只是设置好socket的属性之后就会返回。监听的过程实质由操作系统完成。但是accept会阻塞（也可以设置为非阻塞），如果listen的套接字对应的连接请求队列为空（没有客户端连接请求）,它会一直阻塞等待。&lt;/p&gt;
&lt;h4 id=&#34;客户端和服务端的socket有什么区别&#34;&gt;客户端和服务端的socket有什么区别&lt;/h4&gt;
&lt;p&gt;一个客户端和一个服务端连接，双方&lt;!-- raw HTML omitted --&gt;socket&lt;!-- raw HTML omitted --&gt;产生各自的client_sock_fd和server_sock_fd； server_sock_fd进行&lt;!-- raw HTML omitted --&gt;bind&lt;!-- raw HTML omitted --&gt;和&lt;!-- raw HTML omitted --&gt;listen&lt;!-- raw HTML omitted --&gt;后，&lt;!-- raw HTML omitted --&gt;accept&lt;!-- raw HTML omitted --&gt;准备接受客户端的连接请求；client_sock_fd调用&lt;!-- raw HTML omitted --&gt;connect&lt;!-- raw HTML omitted --&gt;请求连接服务端； 服务端接到请求产生accept_fd，届时accept_fd和client_sock_fd两个套接字可以通讯，而server_sock_fd则可以关闭； 客户端关闭&lt;!-- raw HTML omitted --&gt;close&lt;!-- raw HTML omitted --&gt;（client_sock_fd）后，服务端关闭所有未关闭的fd，通讯彻底断开。&lt;/p&gt;
&lt;p&gt;ps：服务端的&lt;!-- raw HTML omitted --&gt;socket&lt;!-- raw HTML omitted --&gt;产生的套接字只是用来监听的，不能直接用于发送接收数据。&lt;/p&gt;
&lt;h4 id=&#34;socket在内核有buffer为什么还需要应用层buffer&#34;&gt;socket在内核有buffer，为什么还需要应用层buffer？&lt;/h4&gt;
&lt;p&gt;没有应用层buffer从哪拷贝到内核buffer呢？&lt;/p&gt;
&lt;p&gt;假设我们要通过TCP连接来发送100k的数据，在执行write()时，操作系统受某些因素的影响只接受了80k数据，那么由于还剩20k我们该如何处理？是等待内核腾出空间来接受余下的20k？那如果等很久怎么办？难道我们的事件循要在你的等待时间内什么都做不成么？针对以上的问题我们就可以**用一个应用层的write buffer来解决把那些暂时内核无法接受的数据先存在buffer中，然后注册POLLOUT事件，一旦 socket 变得可写就立刻发送数据，如果下次还写不完那么就继续注册POLLOUT事件下次继续写，如果20k数据已经写完了，立即停止关注POLLOUT事件&lt;/p&gt;
&lt;p&gt;####DNS的工作过程和原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906144206282.png&#34; alt=&#34;image-20200906144206282&#34;&gt;&lt;/p&gt;
&lt;p&gt;DNS解析有两种方式：递归查询和迭代查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。&lt;/li&gt;
&lt;li&gt;迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;h4 id=&#34;keep-alive&#34;&gt;Keep-Alive&lt;/h4&gt;
&lt;p&gt;Keep-Alive解决的核心问题是： 一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题&lt;/p&gt;
&lt;p&gt;Keep-Alive还是存在如下问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行的文件传输。&lt;/li&gt;
&lt;li&gt;同域并行请求限制带来的阻塞（6~8）个&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031145659635.png&#34; alt=&#34;image-20201031145659635&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;pipeline&#34;&gt;Pipeline&lt;/h4&gt;
&lt;p&gt;HTTP 管线化可以克服同域并行请求限制带来的阻塞，它是建立在&lt;strong&gt;持久连接&lt;/strong&gt;之上，是把所有请求一并发给服务器，但是服务器需要按照&lt;strong&gt;顺序一个一个响应&lt;/strong&gt;，而不是等到一个响应回来才能发下一个请求，这样就节省了很多请求到服务器的时间。不过，HTTP 管线化&lt;strong&gt;仍旧&lt;/strong&gt;有阻塞的问题，若上一响应迟迟不回，&lt;strong&gt;后面的响应&lt;/strong&gt;都会被阻塞到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031145812040.png&#34; alt=&#34;image-20201031145812040&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;多路复用&#34;&gt;多路复用&lt;/h4&gt;
&lt;p&gt;多路复用代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP 连接并发完成。因为在多路复用之前所有的传输是基于基础文本的，在多路复用中是基于二进制数据帧的传输、消息、流，所以可以做到乱序的传输。多路复用对同一域名下所有请求都是基于流，所以不存在同域并行的阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20201031145943781.png&#34; alt=&#34;image-20201031145943781&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;http请求报文与响应报文格式&#34;&gt;HTTP请求报文与响应报文格式&lt;/h4&gt;
&lt;p&gt;请求报文：请求行（包含请求方法、URI、HTTP版本信息）；请求首部字段；请求内容实体&lt;/p&gt;
&lt;p&gt;响应报文：状态行（包含HTTP版本、状态码及原因短语）；响应首部字段；响应内容实体&lt;/p&gt;
&lt;p&gt;请求和响应头部后面都要空一行，表示头部内容到此结束&lt;/p&gt;
&lt;h4 id=&#34;http头包含哪些字段&#34;&gt;http头包含哪些字段&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;通用首部字段&lt;/strong&gt;（请求报文与响应报文都会使用的首部字段）
Date：创建报文时间
Connection：连接的管理
Cache-Control：缓存的控制
Transfer-Encoding：报文主体的传输编码方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请求首部字段&lt;/strong&gt;（请求报文会使用的首部字段）
Host：请求资源所在服务器
Accept：可处理的媒体类型
Accept-Charset：可接收的字符集
Accept-Encoding：可接受的内容编码
Accept-Language：可接受的自然语言&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应首部字段&lt;/strong&gt;（响应报文会使用的首部字段）
Accept-Ranges：可接受的字节范围
Location：令客户端重新定向到的URI
Server：HTTP服务器的安装信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实体首部字段&lt;/strong&gt;（请求报文与响应报文的的实体部分使用的首部字段）
Allow：资源可支持的HTTP方法
Content-Type：实体主类的类型
Content-Encoding：实体主体适用的编码方式
Content-Language：实体主体的自然语言
Content-Length：实体主体的的字节数&lt;/p&gt;
&lt;h4 id=&#34;状态码&#34;&gt;状态码&lt;/h4&gt;
&lt;p&gt;1xx：在处理了&lt;/p&gt;
&lt;p&gt;2xx：处理成功&lt;/p&gt;
&lt;p&gt;200：请求被正常处理                                                                                                                               204：请求成功但没有资源返回&lt;/p&gt;
&lt;p&gt;3xx：重定向&lt;/p&gt;
&lt;p&gt;301：永久重定向
302：临时重定向&lt;/p&gt;
&lt;p&gt;4xx：出问题了&lt;/p&gt;
&lt;p&gt;400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源&lt;/p&gt;
&lt;p&gt;5xx：服务器挂了&lt;/p&gt;
&lt;p&gt;500：服务器内部错误
503：服务器正忙&lt;/p&gt;
&lt;h4 id=&#34;请求方法&#34;&gt;请求方法&lt;/h4&gt;
&lt;p&gt;GET：用于请求访问已经被URL（统一资源标识符）识别的资源，可以通过URL传参给服务器。&lt;/p&gt;
&lt;p&gt;POST：用于传输信息给服务器，主要功能与Get方法类似，但一般推荐POST方式。&lt;/p&gt;
&lt;p&gt;PUT：传输文件，报文主体包含文件内容，保存到对应URL位置。&lt;/p&gt;
&lt;p&gt;PATCH：对资源进行部分修改&lt;/p&gt;
&lt;p&gt;DELETE：删除文件，与PUT方法相反，删除对应URL位置的文件。&lt;/p&gt;
&lt;p&gt;HEAD：获取报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URL是否有效。&lt;/p&gt;
&lt;p&gt;OPTIONS：查询相应URL支持的HTTP方法。&lt;/p&gt;
&lt;h4 id=&#34;get和post的区别&#34;&gt;get和post的区别&lt;/h4&gt;
&lt;p&gt;get是从服务器上获取数据，post是向服务器传送数据。&lt;/p&gt;
&lt;p&gt;get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是将表单内各个字段与其内容放置在HTML header内一起传送到URL地址。&lt;/p&gt;
&lt;p&gt;get传送的数据量较小（受URL限制），post传送的数据量较大&lt;/p&gt;
&lt;p&gt;get安全性非常低，因为URL是可见的，post安全性较高，但依然以明文的形式存放于 HTTP 的请求头中。&lt;/p&gt;
&lt;p&gt;get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码，post支持标准字符集，可以正确传递中文字符。&lt;/p&gt;
&lt;p&gt;get能被缓存，post不能缓存&lt;/p&gt;
&lt;p&gt;get历史参数保留在浏览器历史中，post参数不会保存在浏览器历史中&lt;/p&gt;
&lt;h4 id=&#34;session与cookies区别以及分别存储在什么地方&#34;&gt;session与cookies区别，以及分别存储在什么地方&lt;/h4&gt;
&lt;p&gt;HTTP 是一种无状态的连接，客户端每次读取 web页面时，服务器都会认为这是一次新的会话。但有时候我们又需要持久保持某些信息，比如登录时的用户名、密码，用户上一次连接时的信息等。这些信息就由 Cookie 和 Session 保存。&lt;/p&gt;
&lt;p&gt;cookie实际上是一小段文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie，客户端浏览器会把cookie保存起来，当浏览器再次请求访问该网站时，浏览器把请求的网站连同该cookie一同提交给服务器，服务器检查该cookie，以此来辨认用户状态。cookie在客户端浏览器上，可能会被伪造不安全&lt;/p&gt;
&lt;p&gt;Session以cookie为基础，同一个客户端每次和服务端交互时，不需要每次都传回所有的 Cookie 值，而是只要传回一个 ID，这个 ID 是客户端第一次访问服务器的时候生成的，而且每个客户端是唯一的。这样每个客户端就有了一个唯一的 session id，客户端只要传回这个session id就行了，session数据放在服务器上（访问多的时候吃性能），session cookie在浏览器内存里。session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）。会话结束后session cookie会消失，更加安全&lt;/p&gt;
&lt;h4 id=&#34;一个网页从输入url到出现渲染画面的整个过程&#34;&gt;一个网页从输入url到出现渲染画面的整个过程&lt;/h4&gt;
&lt;p&gt;DNS 解析:将域名解析成 IP 地址（浏览器缓存-操作系统缓存-路由缓存-ISP互联网服务提供商的DNS服务器-根DNS服务器）&lt;/p&gt;
&lt;p&gt;TCP 连接：TCP 三次握手（见上）&lt;/p&gt;
&lt;p&gt;发送 HTTP 请求&lt;/p&gt;
&lt;p&gt;服务器处理请求并返回 HTTP 报文&lt;/p&gt;
&lt;p&gt;浏览器解析渲染页面：首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。然后是css解析，将css文件解析为样式表对象来渲染DOM树。&lt;/p&gt;
&lt;p&gt;断开连接：TCP 四次挥手&lt;/p&gt;
&lt;h4 id=&#34;http与https区别&#34;&gt;http与https区别&lt;/h4&gt;
&lt;p&gt;HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。&lt;/p&gt;
&lt;p&gt;HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。&lt;/p&gt;
&lt;p&gt;HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。&lt;/p&gt;
&lt;p&gt;HTTPS：&lt;/p&gt;
&lt;p&gt;混合加密实现信息的机密性，解决了窃听的风险。&lt;/p&gt;
&lt;p&gt;数字证书证明服务器公钥可信，解决了冒充的风险。&lt;/p&gt;
&lt;p&gt;摘要算法算出明文摘要，校验数据的完整性，解决了篡改的风险。&lt;/p&gt;
&lt;h4 id=&#34;https原理&#34;&gt;https原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;混合加密&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906135938695.png&#34; alt=&#34;image-20200906135938695&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906140008650.png&#34; alt=&#34;image-20200906140008650&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字证书&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://president810.github.io/Cpp-Interview-Notes/image-20200906142226135.png&#34; alt=&#34;image-20200906142226135&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;摘要&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SSL 提供报文摘要功能来进行完整性保护。&lt;/p&gt;
&lt;p&gt;HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。&lt;/p&gt;
&lt;p&gt;HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。&lt;/p&gt;
&lt;h4 id=&#34;为什么对称加密更快&#34;&gt;为什么对称加密更快&lt;/h4&gt;
&lt;p&gt;对称加密是分组加密的，把数据分组然后再用密钥加密，而非对称是整个数据加密，所以如果数据量大了，加密解密都要比对称加密慢很多&lt;/p&gt;

        
      </description>
    </item>
    
  </channel>
</rss>
