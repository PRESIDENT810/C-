<!DOCTYPE html>
<html lang='en'><head>
  <title>Data Structure | C&#43;&#43; Interview Notes</title>
  <meta charset='utf-8'>
  <meta name="generator" content="Hugo 0.70.0" />
  <meta name = 'viewport' content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'>
  <meta http-equiv = 'X-UA-Compatible' content = 'IE=edge'>
<meta property = 'og:locale' content = 'en_US' />
<meta property="og:type" content="article">
<meta property = 'og:title' content = 'Data Structure' />
<meta name="description" content="数据结构 哈希表 基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P=f(K),其中f成为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P=f(K). 当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址 …">
<meta property = 'og:description' content = '数据结构 哈希表 基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P=f(K),其中f成为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P=f(K). 当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址 …'>
<meta property = 'og:url' content = 'https://president810.github.io/Cpp-Interview-Notes/interview/datastructure/' />
<meta property = 'og:image' content = 'images/%!s()'/>
<meta name = 'twitter:card' content = 'summary_large_image' />
<meta name = 'twitter:creator' content = ''>
<meta name = 'twitter:title' content = 'Data Structure' />
<meta property = 'twitter:description'  content = '数据结构 哈希表 基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P=f(K),其中f成为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P=f(K). 当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址 …'/>
<meta name = 'twitter:image' content = 'images/%!s()' />
<link rel='apple-touch-icon' sizes='180x180' href='https://president810.github.io/Cpp-Interview-Notes/images/icons/apple-touch-icon.png'>
<link rel='icon' type='image/png' sizes='32x32' href='https://president810.github.io/Cpp-Interview-Notes/images/icons/favicon-32x32.png'>
<link rel='icon' type='image/png' sizes='16x16' href='https://president810.github.io/Cpp-Interview-Notes/images/icons/favicon-16x16.png'>
<link rel='manifest' href='https://president810.github.io/Cpp-Interview-Notes/images/icons/site.webmanifest'>

  <link rel='canonical' href='https://president810.github.io/Cpp-Interview-Notes/interview/datastructure/'>
  <link rel = 'stylesheet' href = 'https://president810.github.io/Cpp-Interview-Notes/css/styles.42db596b1300421b76166668f896d65a0e912909aa95394f74e207c69da0d0b652fe2ad414cb6b746661857c824297f791d6df38fce0872ba2a9ccaa421a6b89.css' integrity = 'sha512-QttZaxMAQht2FmZo&#43;JbWWg6RKQmqlTlPdOIHxp2g0LZS/irUFMtrdGZhhXyCQpf3kdbfOPzghyuiqcyqQhpriQ=='>
</head>

  <body><div class = 'nav-drop'>
  <div class = 'nav-body'>
    
    <div class = 'nav-close'></div>
  </div>
</div><header class = 'nav' >
  <nav class = 'nav-menu'>
    <a href='https://president810.github.io/Cpp-Interview-Notes/' class = 'nav-brand nav_item'>C&#43;&#43; Interview Notes</a>
    <div class = 'nav_bar-wrap'>
      <div class = 'nav_bar'></div>
    </div>
  </nav>
</header>


    <main>
  

<section class = 'post_header' style = 'background-image:url(https://president810.github.io/Cpp-Interview-Notes/images/thumbnail.svg);'>
  <h1 class='post_title'>Data Structure</h1>
</section>
<div class = 'post'>
  <article class='post_content'><h2 id="数据结构">数据结构</h2>
<h3 id="哈希表">哈希表</h3>
<p>基本思想：首先在元素的关键字K和元素的位置P之间建立一个对应关系f，使得P=f(K),其中f成为哈希函数。创建哈希表时，把关键字K的元素直接存入地址为f(K)的单元；查找关键字K的元素时利用哈希函数计算出该元素的存储位置P=f(K).
当关键字集合很大时，关键字值不同的元素可能会映像到哈希表的同一地址上，即K1!=K2，但f(K1)=f(K2),这种现象称为hash冲突</p>
<p>开放定址法：
所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入公式为：fi(key) = (f(key)+di) MOD m (di=1,2,3,……,m-1)
用开放定址法解决冲突的做法是：当冲突发生时，使用某种探测技术在散列表中形成一个探测序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址为止（插入时探查到开放的地址则将待插入的新结点存人该地址单元；查找时探测到开放的地址则表明表中无待查的关键字即查找失败）</p>
<p>链地址法：
链地址法的基本思想是：每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来</p>
<h3 id="排序">排序</h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Average time complexity</th>
<th>Worst time complexity</th>
<th align="left">Space complexity</th>
<th>Stable</th>
<th>Place</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bubble sort</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td align="left">O(1)</td>
<td>True</td>
<td>In-place</td>
</tr>
<tr>
<td>Selection sort</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td align="left">O(1)</td>
<td>False</td>
<td>In-place</td>
</tr>
<tr>
<td>Insertion sort</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td align="left">O(1)</td>
<td>True</td>
<td>In-place</td>
</tr>
<tr>
<td>Shell sort</td>
<td>O(n^1.16) (Sedgewick)</td>
<td>O(n^1.33) (Sedgewick)</td>
<td align="left">O(1)</td>
<td>False</td>
<td>In-place</td>
</tr>
<tr>
<td>Heap sort</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td align="left">O(1)</td>
<td>False</td>
<td>In-place</td>
</tr>
<tr>
<td>Merge sort</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td align="left">O(n)</td>
<td>True</td>
<td>Out-place</td>
</tr>
<tr>
<td>Quick sort</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td align="left">O(logn)</td>
<td>False</td>
<td>In-place</td>
</tr>
<tr>
<td>Bucket sort</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td align="left">O(n+k)</td>
<td>True</td>
<td>Out-place</td>
</tr>
<tr>
<td>Counting sort</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td align="left">O(k)</td>
<td>True</td>
<td>Out-place</td>
</tr>
<tr>
<td>Radix sort</td>
<td>O(n*k)</td>
<td>O(n*k)</td>
<td align="left">O(n+k)</td>
<td>True</td>
<td>Out-place</td>
</tr>
</tbody>
</table>
<p>(1)冒泡排序</p>
<p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<p>(2)选择排序</p>
<p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n - 1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<p>(3)插入排序
插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<p>(4)快速排序
快速排序有两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换a[i]和a[j],重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<p>(5)归并排序
归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<p>(6)基数排序
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p>
<p>(7)希尔排序(shell)
希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。</p>
<p>(8)堆排序
我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， &hellip; 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<h3 id="最短路径">最短路径</h3>
<h4 id="迪杰斯特拉">迪杰斯特拉</h4>
<p><img src="https://president810.github.io/Cpp-Interview-Notes/images/image-20200920234535266.png" alt="image-20200920234535266"></p>
<h4 id="贝尔曼福特">贝尔曼福特</h4>
<p>对于一个图G(v,e)(v代表点集，e代表边集)，执行|v|-1次边集的松弛操作，所谓松弛操作，就是对于每个边e1(v,w)，将源点到w的距离更新为：原来源点到w的距离（如果还没有遍历过w则为源点到w距离为∞） 和 源点到v的距离加上v到w的距离 中较小的那个。v-1轮松弛操作之后，判断是否有源点能到达的负环，判断的方法就是，再执行一次边集的松弛操作，如果这一轮松弛操作，有松弛成功的边，那么就说明图中有负环。算法复杂度为O(VE)</p>
<h3 id="最小生成树">最小生成树</h3>
<h4 id="prim">Prim</h4>
<p><img src="https://president810.github.io/Cpp-Interview-Notes/images/image-20200920235531586.png" alt="image-20200920235531586"></p>
<h4 id="kruskal">Kruskal</h4>
<p><img src="https://president810.github.io/Cpp-Interview-Notes/images/image-20200920235551309.png" alt="image-20200920235551309"></p>

    
    <div class = 'post_extra'><div class = 'copy' data-share = 'Copy' data-copied = 'Copied'><svg>
  <use xlink:href="#copy"></use>
</svg>
</div>

    </div>

    
  </article>
  
  <aside><h3>More from C&#43;&#43; Interview Notes</h3>
<ul class='posts aside'>
<li class = 'post_item fp'>
  <a class = 'post_card' href='https://president810.github.io/Cpp-Interview-Notes/interview/c&#43;&#43;/' title = 'C&#43;&#43;' style = 'background-image: url(https://president810.github.io/Cpp-Interview-Notes/images/thumbnail.svg);'>
  </a>
  <div class = 'excerpt'>
    <div class = 'excerpt_meta'><div class = 'copy' data-share = 'Copy' data-copied = 'Copied'><svg>
  <use xlink:href="#copy"></use>
</svg>
</div>

    </div>
    <h3 class = 'post_link'>
      <a href='https://president810.github.io/Cpp-Interview-Notes/interview/c&#43;&#43;/'>C&#43;&#43;</a>
    </h3>
    <p class = 'pale'>C++ 内存机制 基本数据类型 char(1字节），bool（1字节），short（2字节），int（4字节），long（8字节），float（4字节），double（8字节）
怎 …</p>
  </div>
</li>

<li class = 'post_item fp'>
  <a class = 'post_card' href='https://president810.github.io/Cpp-Interview-Notes/interview/operatingsystem/' title = 'Operating System' style = 'background-image: url(https://president810.github.io/Cpp-Interview-Notes/images/thumbnail.svg);'>
  </a>
  <div class = 'excerpt'>
    <div class = 'excerpt_meta'><div class = 'copy' data-share = 'Copy' data-copied = 'Copied'><svg>
  <use xlink:href="#copy"></use>
</svg>
</div>

    </div>
    <h3 class = 'post_link'>
      <a href='https://president810.github.io/Cpp-Interview-Notes/interview/operatingsystem/'>Operating System</a>
    </h3>
    <p class = 'pale'>操作系统 Linux 用户态到内核态的切换  系统调用  这是用户态进程主动要求切换到内核态的一种方式，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前 …</p>
  </div>
</li>

</ul>

  </aside>
  
</div>
<script src = 'https://president810.github.io/Cpp-Interview-Notes/js/autosize.min.js'></script>
<script src = 'https://president810.github.io/Cpp-Interview-Notes/js/timeago.js'></script>
    </main><svg width="0" height="0" class="hidden">
  <symbol viewBox="0 0 699.428 699.428" xmlns="http://www.w3.org/2000/svg" id="copy">
    <path d="M502.714 0H240.428C194.178 0 153 42.425 153 87.429l-25.267.59c-46.228 0-84.019 41.834-84.019 86.838V612c0 45.004 41.179 87.428 87.429 87.428H459c46.249 0 87.428-42.424 87.428-87.428h21.857c46.25 0 87.429-42.424 87.429-87.428v-349.19zM459 655.715H131.143c-22.95 0-43.714-21.441-43.714-43.715V174.857c0-22.272 18.688-42.993 41.638-42.993l23.933-.721v393.429C153 569.576 194.178 612 240.428 612h262.286c0 22.273-20.765 43.715-43.714 43.715zm153-131.143c0 22.271-20.765 43.713-43.715 43.713H240.428c-22.95 0-43.714-21.441-43.714-43.713V87.429c0-22.272 20.764-43.714 43.714-43.714H459c-.351 50.337 0 87.975 0 87.975 0 45.419 40.872 86.882 87.428 86.882H612zm-65.572-349.715c-23.277 0-43.714-42.293-43.714-64.981V44.348L612 174.857zm-43.714 131.537H306c-12.065 0-21.857 9.77-21.857 21.835s9.792 21.835 21.857 21.835h196.714c12.065 0 21.857-9.771 21.857-21.835 0-12.065-9.792-21.835-21.857-21.835zm0 109.176H306c-12.065 0-21.857 9.77-21.857 21.834 0 12.066 9.792 21.836 21.857 21.836h196.714c12.065 0 21.857-9.77 21.857-21.836 0-12.064-9.792-21.834-21.857-21.834z"
    ></path>
  </symbol>
  <symbol viewBox="0 0 60.015 60.015" xmlns="http://www.w3.org/2000/svg" id="reply">
    <path d="M42.007 0h-24c-9.925 0-18 8.075-18 18v14c0 9.59 7.538 17.452 17 17.973v8.344a1.694 1.694 0 0 0 1.699 1.698c.44 0 .873-.173 1.198-.498l1.876-1.876C26.708 52.713 33.259 50 40.227 50h1.78c9.925 0 18-8.075 18-18V18c0-9.925-8.075-18-18-18zm16 32c0 8.822-7.178 16-16 16h-1.78c-7.502 0-14.556 2.921-19.86 8.226l-1.359 1.359V44a1 1 0 1 0-2 0v3.949c-8.356-.52-15-7.465-15-15.949V18c0-8.822 7.178-16 16-16h24c8.822 0 16 7.178 16 16v14z"></path>
  </symbol>
  <symbol xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" id="scan">
    <path d="M456.66 0H385c-8.284 0-15 6.716-15 15s6.716 15 15 15h71.66C470.632 30 482 41.368 482 55.341V127c0 8.284 6.716 15 15 15s15-6.716 15-15V55.341C512 24.826 487.174 0 456.66 0zM15 142c8.284 0 15-6.716 15-15V55.341C30 41.368 41.368 30 55.34 30H127c8.284 0 15-6.716 15-15s-6.716-15-15-15H55.34C24.826 0 0 24.826 0 55.341V127c0 8.284 6.716 15 15 15zm112 340H55.34C41.368 482 30 470.632 30 456.659V385c0-8.284-6.716-15-15-15s-15 6.716-15 15v71.659C0 487.174 24.826 512 55.34 512H127c8.284 0 15-6.716 15-15s-6.716-15-15-15zm370-112c-8.284 0-15 6.716-15 15v71.659C482 470.632 470.632 482 456.66 482H385c-8.284 0-15 6.716-15 15s6.716 15 15 15h71.66c30.515 0 55.34-24.826 55.34-55.341V385c0-8.284-6.716-15-15-15zM341.643 110h47.575c6.497 0 11.782 5.285 11.782 11.782v47.574c0 8.284 6.716 15 15 15s15-6.716 15-15v-47.574C431 98.743 412.256 80 389.218 80h-47.575c-8.284 0-15 6.716-15 15s6.716 15 15 15zM81 121.782v47.574c0 8.284 6.716 15 15 15s15-6.716 15-15v-47.574c0-6.497 5.286-11.782 11.782-11.782h47.575c8.284 0 15-6.716 15-15s-6.716-15-15-15h-47.575C99.744 80 81 98.743 81 121.782zM170.357 400h-47.575c-6.497 0-11.782-5.285-11.782-11.782v-47.574c0-8.284-6.716-15-15-15s-15 6.716-15 15v47.574C81 411.257 99.744 430 122.782 430h47.575c8.284 0 15-6.716 15-15s-6.716-15-15-15zM431 388.218v-47.574c0-8.284-6.716-15-15-15s-15 6.716-15 15v47.574c0 6.497-5.286 11.782-11.782 11.782h-47.575c-8.284 0-15 6.716-15 15s6.716 15 15 15h47.575C412.256 430 431 411.257 431 388.218zM1 256c0 8.284 6.716 15 15 15h480c8.284 0 15-6.716 15-15s-6.716-15-15-15H16c-8.284 0-15 6.716-15 15z"></path>
  </symbol>
</svg>
<footer class="footer">
  <div class="footer_inner wrap pale">
    <p>&copy;&nbsp;<span class="year"></span>&nbsp;C&#43;&#43; Interview Notes.
    Designed by  <a href = '<no value>' title = 'Linkedin Profile'><no value></a></p>
  </div>
</footer><script type="text/javascript" src="https://president810.github.io/Cpp-Interview-Notes/js/bundle.69353a6a68a26a818a66ae1bfabde28065bf92b30744daaae9dab05bd82d5be9a7784d739ec8a76daad658c275d2fb8d483329dfef5c6b3803fd3da39e338680.js" integrity="sha512-aTU6amiiaoGKZq4b&#43;r3igGW/krMHRNqq6dqwW9gtW&#43;mneE1znsinbarWWMJ10vuNSDMp3&#43;9cazgD/T2jnjOGgA==" crossorigin="anonymous"></script>

  </body>
</html>
